; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -obl_main.o --depend=bl_main.d --feedback=bootloader.fed --cpu=Cortex-M3 --apcs=interwork -O1 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\Luminary -D__MICROLIB --omf_browse=bl_main.crf bl_main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ConfigureDevice PROC
;;;166    void
;;;167    ConfigureDevice(void)
000000  b510              PUSH     {r4,lr}
;;;168    {
;;;169    #ifdef UART_ENABLE_UPDATE
;;;170        unsigned long ulProcRatio;
;;;171    #endif
;;;172    
;;;173    #ifdef CRYSTAL_FREQ
;;;174        //
;;;175        // Since the crystal frequency was specified, enable the main oscillator
;;;176        // and clock the processor from it.
;;;177        //
;;;178        SYSCTL->RCC &= ~(SYSCTL_RCC_MOSCDIS);
000002  4ca3              LDR      r4,|L1.656|
000004  f8540c64          LDR      r0,[r4,#-0x64]
000008  f0200001          BIC      r0,r0,#1
00000c  f8440c64          STR      r0,[r4,#-0x64]
;;;179        Delay(524288);
000010  f44f2000          MOV      r0,#0x80000
000014  f7fffffe          BL       Delay
;;;180        SYSCTL->RCC = ((SYSCTL->RCC & (~SYSCTL_RCC_OSCSRC_M)) | SYSCTL_RCC_OSCSRC_MAIN);
000018  f8540c64          LDR      r0,[r4,#-0x64]
00001c  f0200030          BIC      r0,r0,#0x30
000020  f8440c64          STR      r0,[r4,#-0x64]
;;;181    
;;;182        //
;;;183        // Set the flash programming time based on the specified crystal frequency.
;;;184        //
;;;185        FLASH->USECRL = ((CRYSTAL_FREQ + 999999) / 1000000) - 1;
000024  2007              MOVS     r0,#7
000026  67e0              STR      r0,[r4,#0x7c]
;;;186    #else
;;;187        //
;;;188        // Set the flash to program at 16 MHz since that is just beyond the fastest
;;;189        // that we could run.
;;;190        //
;;;191        FLASH->USECRL = 15;
;;;192    #endif
;;;193    
;;;194    #ifdef I2C_ENABLE_UPDATE
;;;195        //
;;;196        // Enable the clocks to the I2C and GPIO modules.
;;;197        //
;;;198        SYSCTL->RCGC[2] |= SYSCTL_RCGC2_GPIOB;
;;;199        SYSCTL->RCGC[1] |= SYSCTL_RCGC1_I2C0;
;;;200    
;;;201        //
;;;202        // Configure the GPIO pins for hardware control, open drain with pull-up,
;;;203        // and enable them.
;;;204        //
;;;205        GPIOB->AFSEL = (1 << 7) | I2C_PINS;
;;;206        GPIOB->DEN = (1 << 7) | I2C_PINS;
;;;207        GPIOB->ODR = I2C_PINS;
;;;208    
;;;209        //
;;;210        // Enable the I2C Slave Mode.
;;;211        //
;;;212        HWREG(I2C0_MASTER_BASE + I2C_O_MCR) = I2C_MCR_MFE | I2C_MCR_SFE;
;;;213    
;;;214        //
;;;215        // Setup the I2C Slave Address.
;;;216        //
;;;217        HWREG(I2C0_SLAVE_BASE + I2C_O_SOAR) = I2C_SLAVE_ADDR;
;;;218    
;;;219        //
;;;220        // Enable the I2C Slave Device on the I2C bus.
;;;221        //
;;;222        HWREG(I2C0_SLAVE_BASE + I2C_O_SCSR) = I2C_SCSR_DA;
;;;223    #endif
;;;224    
;;;225    #ifdef SSI_ENABLE_UPDATE
;;;226        //
;;;227        // Enable the clocks to the SSI and GPIO modules.
;;;228        //
;;;229        SYSCTL>RCGC[2] = SYSCTL_RCGC2_GPIOA;
;;;230        SYSCTL>RCGC[1] = SYSCTL_RCGC1_SSI0;
;;;231    
;;;232        //
;;;233        // Make the pin be peripheral controlled.
;;;234        //
;;;235        GPIOA->AFSEL |= SSI_PINS;
;;;236        GPIOA->DEN |= SSI_PINS;
;;;237    
;;;238        //
;;;239        // Set the SSI protocol to Motorola with default clock high and data
;;;240        // valid on the rising edge.
;;;241        //
;;;242        SSI0->CR0 = (SSI_CR0_SPH | SSI_CR0_SPO |
;;;243                    (DATA_BITS_SSI - 1));
;;;244    
;;;245        //
;;;246        // Enable the SSI interface in slave mode.
;;;247        //
;;;248        SSI0->CR1 = SSI_CR1_MS | SSI_CR1_SSE;
;;;249    #endif
;;;250    
;;;251        Init_Ssi();		//初始化SSI 控制显示
000028  f7fffffe          BL       Init_Ssi
;;;252    
;;;253        Init_Gpio();        //参数I/O口
00002c  f7fffffe          BL       Init_Gpio
;;;254        Reset_HD7279();     //复位显示
000030  f7fffffe          BL       Reset_HD7279
;;;255        Disp_Boot();        //按方式0译码 显示引导状态
000034  f7fffffe          BL       Disp_Boot
;;;256        Disp_Sts=0x80;      //显示状态为显示
000038  4996              LDR      r1,|L1.660|
00003a  2080              MOVS     r0,#0x80
00003c  7008              STRB     r0,[r1,#0]
;;;257        Delay(5000);        //
00003e  f2413088          MOV      r0,#0x1388
000042  f7fffffe          BL       Delay
;;;258    #ifdef UART_ENABLE_UPDATE
;;;259        //
;;;260        // Enable the the clocks to the UART and GPIO modules.
;;;261        //
;;;262        SYSCTL->RCGC[2] |= SYSCTL_RCGC2_GPIOA;
000046  6c60              LDR      r0,[r4,#0x44]
000048  f0400001          ORR      r0,r0,#1
00004c  6460              STR      r0,[r4,#0x44]
;;;263        SYSCTL->RCGC[1] |= SYSCTL_RCGC1_UART0;
00004e  6c20              LDR      r0,[r4,#0x40]
000050  f0400001          ORR      r0,r0,#1
000054  6420              STR      r0,[r4,#0x40]
;;;264    
;;;265        //
;;;266        // Keep attempting to sync until we are successful.
;;;267        //
;;;268    #ifdef UART_AUTOBAUD
;;;269        while(UARTAutoBaud(&ulProcRatio) < 0)
;;;270        {
;;;271        }
;;;272    #else
;;;273        ulProcRatio = UART_BAUD_RATIO(UART_FIXED_BAUDRATE);
;;;274    #endif
;;;275    
;;;276        //
;;;277        // Set GPIO A0 and A1 as UART pins.
;;;278        //
;;;279        GPIOA->AFSEL |= UART_PINS;
000056  4890              LDR      r0,|L1.664|
000058  6801              LDR      r1,[r0,#0]
00005a  f0410103          ORR      r1,r1,#3
00005e  6001              STR      r1,[r0,#0]
;;;280    
;;;281        //
;;;282        // Set the pin type.
;;;283        //
;;;284        GPIOA->DEN |= UART_PINS;
000060  f8d010fc          LDR      r1,[r0,#0xfc]
000064  f0410103          ORR      r1,r1,#3
000068  f8c010fc          STR      r1,[r0,#0xfc]
;;;285        //
;;;286        // Set the baud rate.
;;;287        //
;;;288        UART0->IBRD = ulProcRatio >> 6;
00006c  488b              LDR      r0,|L1.668|
00006e  f04f011a          MOV      r1,#0x1a
000072  6241              STR      r1,[r0,#0x24]
;;;289        UART0->FBRD = ulProcRatio & UART_FBRD_DIVFRAC_M;
000074  f04f0103          MOV      r1,#3
000078  6281              STR      r1,[r0,#0x28]
;;;290    
;;;291        //
;;;292        // Set data length, parity, and number of stop bits to 8-N-1.
;;;293        //
;;;294        UART0->LCRH = UART_LCRH_WLEN_8 | UART_LCRH_FEN;
00007a  f04f0170          MOV      r1,#0x70
00007e  62c1              STR      r1,[r0,#0x2c]
;;;295    
;;;296        //
;;;297        // Enable RX, TX, and the UART.
;;;298        //
;;;299        UART0->CTL = (UART_CTL_UARTEN | UART_CTL_TXE |
000080  f2403101          MOV      r1,#0x301
000084  6301              STR      r1,[r0,#0x30]
;;;300                                          UART_CTL_RXE);
;;;301    
;;;302    #ifdef UART_AUTOBAUD
;;;303        //
;;;304        // Need to ack in the UART case to hold it up while we get things set up.
;;;305        //
;;;306    	Delay(20000);
;;;307        AckPacket();
;;;308    #endif
;;;309    #endif
;;;310    }
000086  bd10              POP      {r4,pc}
;;;311    
                          ENDP

                  Updater PROC
;;;324    void
;;;325    Updater(void)
000088  e92d4ff8          PUSH     {r3-r11,lr}
;;;326    {
;;;327        unsigned long ulSize, ulTemp, ulFlashSize;
;;;328    
;;;329        g_pucDataBuffer = ((unsigned char *)g_pulDataBuffer) + 3;
00008c  4e81              LDR      r6,|L1.660|
00008e  4884              LDR      r0,|L1.672|
000090  60f0              STR      r0,[r6,#0xc]  ; g_pucDataBuffer
;;;330    
;;;331        g_ulTransferAddress = 0xffffffff;
000092  f04f30ff          MOV      r0,#0xffffffff
000096  60b0              STR      r0,[r6,#8]  ; g_ulTransferAddress
000098  f8df8204          LDR      r8,|L1.672|
;;;332    
;;;333        while(1)
;;;334         {
;;;335          ulSize = sizeof(g_pulDataBuffer) - 3;
;;;336          if(ReceivePacket(g_pucDataBuffer, &ulSize) != 0)
;;;337           continue;
;;;338          switch(g_pucDataBuffer[0])
;;;339           {
;;;340            case COMMAND_PING: 
;;;341             {//0x20 ECHO 计算机查询命令 
;;;342              g_ucStatus = COMMAND_RET_SUCCESS;
;;;343              AckPacket();
;;;344              break;
;;;345             }
;;;346            case COMMAND_DOWNLOAD:
;;;347             {//0x21 传输程序偏移地址和程序长度
;;;348              g_ucStatus = COMMAND_RET_SUCCESS;
;;;349              do
;;;350               {
;;;351                if(ulSize != 9)
;;;352                 {
;;;353                  g_ucStatus = COMMAND_RET_INVALID_CMD;
;;;354                  break;
;;;355                 }
;;;356                g_ulTransferAddress = SwapWord(g_pulDataBuffer[1]);	 //起始地址
;;;357                g_ulTransferSize = SwapWord(g_pulDataBuffer[2]);
;;;358                ulFlashSize = (((SYSCTL->DC0 & SYSCTL_DC0_FLASHSZ_M) + 1) << 11);
;;;359    #ifdef FLASH_RSVD_SPACE
;;;360                if((ulFlashSize - FLASH_RSVD_SPACE) != g_ulTransferAddress)
;;;361                 {
;;;362                  ulFlashSize -= FLASH_RSVD_SPACE;
;;;363                 }
;;;364    #endif
;;;365    
;;;366                if((
;;;367    #ifdef ENABLE_BL_UPDATE
;;;368                   (g_ulTransferAddress != 0) &&
;;;369    #endif
;;;370    #ifdef FLASH_RSVD_SPACE
;;;371                   (g_ulTransferAddress !=(ulFlashSize - FLASH_RSVD_SPACE)) &&
;;;372    #endif
;;;373                   (g_ulTransferAddress != APP_START_ADDRESS)) ||
;;;374                   ((g_ulTransferAddress + g_ulTransferSize) > ulFlashSize) ||
;;;375                   ((g_ulTransferAddress & 3) != 0))
;;;376                    {
;;;377                     g_ucStatus = COMMAND_RET_INVALID_ADR;
;;;378                     break;
;;;379                    }
;;;380    #ifndef FLASH_CODE_PROTECTION
;;;381                ulFlashSize = g_ulTransferAddress + g_ulTransferSize;
;;;382    #endif
;;;383    
;;;384                FLASH->FCMISC = FLASH_FCMISC_AMISC;
00009c  2501              MOVS     r5,#1
00009e  4c81              LDR      r4,|L1.676|
0000a0  f04f0b40          MOV      r11,#0x40             ;342
0000a4  f1a80803          SUB      r8,r8,#3              ;329
0000a8  2700              MOVS     r7,#0                 ;329
                  |L1.170|
0000aa  2075              MOVS     r0,#0x75              ;335
0000ac  9000              STR      r0,[sp,#0]            ;335
0000ae  4669              MOV      r1,sp                 ;336
0000b0  68f0              LDR      r0,[r6,#0xc]          ;336  ; g_pucDataBuffer
0000b2  f7fffffe          BL       ReceivePacket
0000b6  2800              CMP      r0,#0                 ;336
0000b8  d1f7              BNE      |L1.170|
0000ba  68f0              LDR      r0,[r6,#0xc]          ;338  ; g_pucDataBuffer
0000bc  7800              LDRB     r0,[r0,#0]            ;338
0000be  3820              SUBS     r0,r0,#0x20           ;338
0000c0  2806              CMP      r0,#6                 ;338
0000c2  d26f              BCS      |L1.420|
0000c4  e8dff000          TBB      [pc,r0]               ;338
0000c8  0308426f          DCB      0x03,0x08,0x42,0x6f
0000cc  77d1              DCB      0x77,0xd1
0000ce  f886b001          STRB     r11,[r6,#1]           ;342
0000d2  f7fffffe          BL       AckPacket
0000d6  e7e8              B        |L1.170|
0000d8  f886b001          STRB     r11,[r6,#1]           ;348
0000dc  9800              LDR      r0,[sp,#0]            ;351
0000de  2809              CMP      r0,#9                 ;351
0000e0  d002              BEQ      |L1.232|
0000e2  2042              MOVS     r0,#0x42              ;353
0000e4  7070              STRB     r0,[r6,#1]            ;353
0000e6  e02a              B        |L1.318|
                  |L1.232|
0000e8  f8d80004          LDR      r0,[r8,#4]            ;356  ; g_pulDataBuffer
0000ec  ba00              REV      r0,r0                 ;356
0000ee  60b0              STR      r0,[r6,#8]            ;356  ; g_ulTransferAddress
0000f0  f8d81008          LDR      r1,[r8,#8]            ;357  ; g_pulDataBuffer
0000f4  ba09              REV      r1,r1                 ;357
0000f6  6071              STR      r1,[r6,#4]            ;357  ; g_ulTransferSize
0000f8  4a65              LDR      r2,|L1.656|
0000fa  3ac4              SUBS     r2,r2,#0xc4           ;358
0000fc  6892              LDR      r2,[r2,#8]            ;358
0000fe  b292              UXTH     r2,r2                 ;358
000100  1c52              ADDS     r2,r2,#1              ;358
000102  02d2              LSLS     r2,r2,#11             ;358
000104  b110              CBZ      r0,|L1.268|
000106  f5b06f40          CMP      r0,#0xc00             ;373
00010a  d104              BNE      |L1.278|
                  |L1.268|
00010c  4401              ADD      r1,r1,r0              ;374
00010e  4291              CMP      r1,r2                 ;374
000110  d801              BHI      |L1.278|
000112  0781              LSLS     r1,r0,#30             ;375
000114  d002              BEQ      |L1.284|
                  |L1.278|
000116  2043              MOVS     r0,#0x43              ;377
000118  7070              STRB     r0,[r6,#1]            ;377
00011a  e010              B        |L1.318|
                  |L1.284|
00011c  6165              STR      r5,[r4,#0x14]
;;;385    
;;;386                for(ulTemp = g_ulTransferAddress; ulTemp < ulFlashSize;
;;;387                    ulTemp += 0x400)
;;;388                 {
;;;389                  FLASH->FMA = ulTemp;
;;;390                  FLASH->FMC = FLASH_FMC_WRKEY | FLASH_FMC_ERASE;
00011e  4b62              LDR      r3,|L1.680|
000120  e006              B        |L1.304|
                  |L1.290|
000122  6020              STR      r0,[r4,#0]            ;389
000124  60a3              STR      r3,[r4,#8]
                  |L1.294|
;;;391                  while(FLASH->FMC & FLASH_FMC_ERASE)
000126  68a1              LDR      r1,[r4,#8]
000128  0789              LSLS     r1,r1,#30
00012a  d4fc              BMI      |L1.294|
00012c  f5006080          ADD      r0,r0,#0x400          ;387
                  |L1.304|
000130  4290              CMP      r0,r2                 ;386
000132  d3f6              BCC      |L1.290|
;;;392                   {
;;;393                   }
;;;394                 }
;;;395                
;;;396                if(FLASH->FCRIS & FLASH_FCRIS_ARIS)
000134  68e0              LDR      r0,[r4,#0xc]
000136  07c0              LSLS     r0,r0,#31
000138  d001              BEQ      |L1.318|
;;;397                 {
;;;398                  g_ucStatus = COMMAND_RET_FLASH_FAIL;
00013a  2044              MOVS     r0,#0x44
00013c  7070              STRB     r0,[r6,#1]
                  |L1.318|
;;;399                 }
;;;400               }
;;;401              while(0);
;;;402    
;;;403              if(g_ucStatus != COMMAND_RET_SUCCESS)
00013e  7870              LDRB     r0,[r6,#1]  ; g_ucStatus
000140  2840              CMP      r0,#0x40
000142  d000              BEQ      |L1.326|
;;;404               {
;;;405                g_ulTransferSize = 0;
000144  6077              STR      r7,[r6,#4]  ; g_ulTransferSize
                  |L1.326|
;;;406               }
;;;407              AckPacket();
000146  f7fffffe          BL       AckPacket
;;;408              break;
00014a  e7ae              B        |L1.170|
;;;409             }
;;;410            case COMMAND_RUN:
;;;411             {//0x22 +4字节 程序地址 程序运行
;;;412              AckPacket();
00014c  f7fffffe          BL       AckPacket
;;;413              if(ulSize != 5)
000150  9800              LDR      r0,[sp,#0]
000152  2805              CMP      r0,#5
000154  d002              BEQ      |L1.348|
;;;414               {
;;;415                g_ucStatus = COMMAND_RET_INVALID_CMD;
000156  2042              MOVS     r0,#0x42
000158  7070              STRB     r0,[r6,#1]
;;;416                //
;;;417                // This packet has been handled.
;;;418                //
;;;419                break;
00015a  e7a6              B        |L1.170|
                  |L1.348|
;;;420               }
;;;421              
;;;422              //
;;;423              // Get the address to which control should be transferred.
;;;424              //
;;;425              g_ulTransferAddress = SwapWord(g_pulDataBuffer[1]);
00015c  f8d80004          LDR      r0,[r8,#4]  ; g_pulDataBuffer
000160  ba00              REV      r0,r0
000162  60b0              STR      r0,[r6,#8]  ; g_ulTransferAddress
;;;426              
;;;427              //
;;;428              // This determines the size of the flash available on the
;;;429              // device in use.
;;;430              //
;;;431              ulFlashSize = ((SYSCTL->DC0 & SYSCTL_DC0_FLASHSZ_M + 1) << 11);
000164  494a              LDR      r1,|L1.656|
000166  39c4              SUBS     r1,r1,#0xc4
000168  6889              LDR      r1,[r1,#8]
00016a  f4013180          AND      r1,r1,#0x10000
00016e  02c9              LSLS     r1,r1,#11
;;;432              
;;;433              //
;;;434              // Test if the transfer address is valid for this device.
;;;435              //
;;;436              if(g_ulTransferAddress >= ulFlashSize)
000170  4288              CMP      r0,r1
000172  d302              BCC      |L1.378|
;;;437               {
;;;438                //
;;;439                // Indicate that an invalid address was specified.
;;;440                //
;;;441                g_ucStatus = COMMAND_RET_INVALID_ADR;
000174  2043              MOVS     r0,#0x43
000176  7070              STRB     r0,[r6,#1]
;;;442               
;;;443                //
;;;444                // This packet has been handled.
;;;445                //
;;;446                break;
000178  e797              B        |L1.170|
                  |L1.378|
;;;447               }
;;;448              
;;;449              //
;;;450              // Make sure that the ACK packet has been sent.
;;;451              //
;;;452              FlushData();
00017a  f7fffffe          BL       UARTFlush
;;;453              
;;;454              //
;;;455              // Reset and disable the peripherals used by the boot loader.
;;;456              //
;;;457              SYSCTL->RCGC[1] = 0;
00017e  4844              LDR      r0,|L1.656|
000180  38c4              SUBS     r0,r0,#0xc4
000182  f8c07104          STR      r7,[r0,#0x104]
;;;458              SYSCTL->RCGC[2] = 0;
000186  f8c07108          STR      r7,[r0,#0x108]
;;;459              SYSCTL->SRCR[1] = (SYSCTL_SRCR1_I2C0 | SYSCTL_SRCR1_SSI0 |
00018a  f2410111          MOV      r1,#0x1011
00018e  6441              STR      r1,[r0,#0x44]
;;;460                                 SYSCTL_SRCR1_UART0);
;;;461              SYSCTL->SRCR[2] = SYSCTL_SRCR2_GPIOA | SYSCTL_SRCR2_GPIOB;
000190  2103              MOVS     r1,#3
000192  6481              STR      r1,[r0,#0x48]
;;;462              SYSCTL->SRCR[1] = 0;
000194  6447              STR      r7,[r0,#0x44]
;;;463              SYSCTL->SRCR[2] = 0;
000196  6487              STR      r7,[r0,#0x48]
;;;464              
;;;465              //
;;;466              // Branch to the specified address.  This should never return.
;;;467              // If it does, very bad things will likely happen since it is
;;;468              // likely that the copy of the boot loader in SRAM will have
;;;469              // been overwritten.
;;;470              //
;;;471              ((void (*)(void))g_ulTransferAddress)();
000198  68b0              LDR      r0,[r6,#8]  ; g_ulTransferAddress
00019a  4780              BLX      r0
;;;472              
;;;473              //
;;;474              // In case this ever does return and the boot loader is still
;;;475              // intact, simply reset the device.
;;;476              //
;;;477              NVIC->APINT = (NVIC_APINT_VECTKEY |
00019c  4944              LDR      r1,|L1.688|
00019e  4843              LDR      r0,|L1.684|
0001a0  6008              STR      r0,[r1,#0]
                  |L1.418|
;;;478                             NVIC_APINT_SYSRESETREQ);
;;;479              
;;;480              //
;;;481              // The microcontroller should have reset, so this should
;;;482              // never be reached.  Just in case, loop forever.
;;;483              //
;;;484              while(1)
0001a2  e7fe              B        |L1.418|
                  |L1.420|
0001a4  e069              B        |L1.634|
;;;485               {
;;;486               }
;;;487             }
;;;488            //
;;;489            // This command just returns the status of the last command that
;;;490            // was sent.
;;;491            //
;;;492            case COMMAND_GET_STATUS:
;;;493             {//0x23 获取状态
;;;494              //
;;;495              // Acknowledge that this command was received correctly.  This
;;;496              // does not indicate success, just that the command was
;;;497              // received.
;;;498              //
;;;499              AckPacket();
0001a6  f7fffffe          BL       AckPacket
;;;500             
;;;501              //
;;;502              // Return the status to the updater.
;;;503              //
;;;504              SendPacket(&g_ucStatus, 1);
0001aa  483a              LDR      r0,|L1.660|
0001ac  2101              MOVS     r1,#1
0001ae  1c40              ADDS     r0,r0,#1
0001b0  f7fffffe          BL       SendPacket
                  |L1.436|
;;;505             
;;;506              //
;;;507              // Go back and wait for a new command.
;;;508              //
;;;509              break;
0001b4  e779              B        |L1.170|
;;;510             }
;;;511            //
;;;512            // This command is sent to transfer data to the device following
;;;513            // a download command.
;;;514            //
;;;515            case COMMAND_SEND_DATA:
;;;516             {//0x24 下载数据
;;;517              //
;;;518              // Until determined otherwise, the command status is success.
;;;519              //
;;;520              g_ucStatus = COMMAND_RET_SUCCESS;
0001b6  f886b001          STRB     r11,[r6,#1]
;;;521             
;;;522              //
;;;523              // If this is overwriting the boot loader then the application
;;;524              // has already been erased so now erase the boot loader.
;;;525              //
;;;526              if(g_ulTransferAddress == 0)
0001ba  68b0              LDR      r0,[r6,#8]  ; g_ulTransferAddress
0001bc  b998              CBNZ     r0,|L1.486|
;;;527               {
;;;528                //
;;;529                // Clear the flash access interrupt.
;;;530                //
;;;531                FLASH->FCMISC = FLASH_FCMISC_AMISC;
0001be  6165              STR      r5,[r4,#0x14]
;;;532                
;;;533                //
;;;534                // Erase the application before the boot loader.
;;;535                //
;;;536                for(ulTemp = 0; ulTemp < APP_START_ADDRESS;
0001c0  2000              MOVS     r0,#0
0001c2  4a39              LDR      r2,|L1.680|
0001c4  f44f6340          MOV      r3,#0xc00             ;373
                  |L1.456|
;;;537                    ulTemp += 0x400)
;;;538                 {
;;;539                  //
;;;540                  // Erase this block.
;;;541                  //
;;;542                  FLASH->FMA = ulTemp;
0001c8  6020              STR      r0,[r4,#0]
;;;543                  FLASH->FMC = FLASH_FMC_WRKEY | FLASH_FMC_ERASE;
0001ca  60a2              STR      r2,[r4,#8]
                  |L1.460|
;;;544                 
;;;545                  //
;;;546                  // Wait until this block has been erased.
;;;547                  //
;;;548                  while(FLASH->FMC & FLASH_FMC_ERASE)
0001cc  68a1              LDR      r1,[r4,#8]
0001ce  0789              LSLS     r1,r1,#30
0001d0  d4fc              BMI      |L1.460|
0001d2  f5006080          ADD      r0,r0,#0x400          ;537
0001d6  4298              CMP      r0,r3                 ;536
0001d8  d3f6              BCC      |L1.456|
;;;549                   {
;;;550                   }
;;;551                 }
;;;552                //
;;;553                // Return an error if an access violation occurred.
;;;554                //
;;;555                if(FLASH->FCRIS & FLASH_FCRIS_ARIS)
0001da  68e0              LDR      r0,[r4,#0xc]
0001dc  07c0              LSLS     r0,r0,#31
0001de  d002              BEQ      |L1.486|
;;;556                 {
;;;557                  //
;;;558                  // Setting g_ulTransferSize to zero makes
;;;559                  // COMMAND_SEND_DATA fail to accept any more data.
;;;560                  //
;;;561                  g_ulTransferSize = 0;
0001e0  6077              STR      r7,[r6,#4]  ; g_ulTransferSize
;;;562                 
;;;563                  //
;;;564                  // Indicate that the flash erase failed.
;;;565                  //
;;;566                  g_ucStatus = COMMAND_RET_FLASH_FAIL;
0001e2  2044              MOVS     r0,#0x44
0001e4  7070              STRB     r0,[r6,#1]
                  |L1.486|
;;;567                 }
;;;568               }
;;;569              //
;;;570              // Take one byte off for the command.
;;;571              //
;;;572              ulSize = ulSize - 1;
0001e6  9900              LDR      r1,[sp,#0]
0001e8  1e49              SUBS     r1,r1,#1
0001ea  9100              STR      r1,[sp,#0]
;;;573             
;;;574              //
;;;575              // Check if there are any more bytes to receive.
;;;576              //
;;;577              if(g_ulTransferSize >= ulSize)
0001ec  f8d69004          LDR      r9,[r6,#4]  ; g_ulTransferSize
0001f0  4589              CMP      r9,r1
0001f2  d325              BCC      |L1.576|
;;;578               {
;;;579                //
;;;580                // This function is a stub to show where to insert a
;;;581                // function to decrypt the data as it is received.
;;;582                //
;;;583    #ifdef ENABLE_DECRYPTION
;;;584                DecryptData(g_pucDataBuffer + 1, ulSize);
;;;585    #endif
;;;586                //
;;;587                // Clear the flash access interrupt.
;;;588                //
;;;589                FLASH->FCMISC = FLASH_FCMISC_AMISC;
0001f4  6165              STR      r5,[r4,#0x14]
;;;590    
;;;591                //
;;;592                // Loop over the words to program.
;;;593                //
;;;594                for(ulTemp = 0; ulTemp < ((ulSize + 3) & ~3); ulTemp += 4)
0001f6  2000              MOVS     r0,#0
;;;595                 {
;;;596                  //
;;;597                  // Program the next word.
;;;598                  //
;;;599                  FLASH->FMA = g_ulTransferAddress + ulTemp;
;;;600                  FLASH->FMD = g_pulDataBuffer[(ulTemp >> 2) + 1];
;;;601                  FLASH->FMC = FLASH_FMC_WRKEY | FLASH_FMC_WRITE;
0001f8  f8dfa0ac          LDR      r10,|L1.680|
0001fc  1ccb              ADDS     r3,r1,#3              ;594
0001fe  f1aa0a01          SUB      r10,r10,#1
000202  f0230c03          BIC      r12,r3,#3             ;594
000206  68b2              LDR      r2,[r6,#8]            ;594
000208  e00c              B        |L1.548|
                  |L1.522|
00020a  1813              ADDS     r3,r2,r0              ;599
00020c  6023              STR      r3,[r4,#0]            ;599
00020e  eb050390          ADD      r3,r5,r0,LSR #2       ;600
000212  f8583023          LDR      r3,[r8,r3,LSL #2]     ;600
000216  6063              STR      r3,[r4,#4]            ;600
000218  f8c4a008          STR      r10,[r4,#8]
                  |L1.540|
;;;602                
;;;603                  //
;;;604                  // Wait until the word has been programmed.
;;;605                  //
;;;606                  while(FLASH->FMC & FLASH_FMC_WRITE)
00021c  68a3              LDR      r3,[r4,#8]
00021e  07db              LSLS     r3,r3,#31
000220  d1fc              BNE      |L1.540|
000222  1d00              ADDS     r0,r0,#4              ;594
                  |L1.548|
000224  4584              CMP      r12,r0                ;594
000226  d8f0              BHI      |L1.522|
;;;607                   {
;;;608                   }
;;;609                 }
;;;610                //
;;;611                // Return an error if an access violation occurred.
;;;612                //
;;;613                if(FLASH->FCRIS & FLASH_FCRIS_ARIS)
000228  68e0              LDR      r0,[r4,#0xc]
00022a  07c0              LSLS     r0,r0,#31
00022c  d002              BEQ      |L1.564|
;;;614                 {
;;;615                  //
;;;616                  // Indicate that the flash programming failed.
;;;617                  //
;;;618                  g_ucStatus = COMMAND_RET_FLASH_FAIL;
00022e  2044              MOVS     r0,#0x44
000230  7070              STRB     r0,[r6,#1]
000232  e007              B        |L1.580|
                  |L1.564|
;;;619                 }
;;;620                else
;;;621                 {
;;;622                  //
;;;623                  // Now update the address to program.
;;;624                  //
;;;625                  g_ulTransferSize -= ulSize;
000234  eba90001          SUB      r0,r9,r1
000238  6070              STR      r0,[r6,#4]  ; g_ulTransferSize
;;;626                  g_ulTransferAddress += ulSize;
00023a  1850              ADDS     r0,r2,r1
00023c  60b0              STR      r0,[r6,#8]  ; g_ulTransferAddress
00023e  e001              B        |L1.580|
                  |L1.576|
;;;627                 }
;;;628               }
;;;629              else
;;;630               {
;;;631                 //
;;;632                 // This indicates that too much data is being sent to the
;;;633                 // device.
;;;634                 //
;;;635                 g_ucStatus = COMMAND_RET_INVALID_ADR;
000240  2043              MOVS     r0,#0x43
000242  7070              STRB     r0,[r6,#1]
                  |L1.580|
;;;636               }
;;;637              //
;;;638              // Acknowledge that this command was received correctly.  This
;;;639              // does not indicate success, just that the command was
;;;640              // received.
;;;641              //
;;;642              Disp_Sts++;
000244  7830              LDRB     r0,[r6,#0]  ; Disp_Sts
000246  1c40              ADDS     r0,r0,#1
000248  b2c0              UXTB     r0,r0
00024a  7030              STRB     r0,[r6,#0]
;;;643              if(Disp_Sts&0x04)    //每4条指令改变一次显示
00024c  0741              LSLS     r1,r0,#29
00024e  d509              BPL      |L1.612|
;;;644               {
;;;645                if(Disp_Sts&0x80)  //判断当前是否显示
000250  0600              LSLS     r0,r0,#24
000252  d503              BPL      |L1.604|
;;;646                 {
;;;647                  Disp_Sts=0x00;   //清除显示标志
000254  7037              STRB     r7,[r6,#0]
;;;648                  Disp_Blank();    //清除显示
000256  f7fffffe          BL       Disp_Blank
00025a  e003              B        |L1.612|
                  |L1.604|
;;;649                 }
;;;650                else
;;;651                 {
;;;652                  Disp_Sts=0x80;
00025c  2080              MOVS     r0,#0x80
00025e  7030              STRB     r0,[r6,#0]
;;;653                  Disp_Boot();
000260  f7fffffe          BL       Disp_Boot
                  |L1.612|
;;;654                 }
;;;655               } 	 	 			
;;;656              AckPacket();
000264  f7fffffe          BL       AckPacket
;;;657              //
;;;658              // Go back and wait for a new command.
;;;659              //
;;;660              break;
000268  e71f              B        |L1.170|
;;;661             }
;;;662            //
;;;663            // This command is used to reset the device.
;;;664            //
;;;665            case COMMAND_RESET:
;;;666             {//0x25 复位
;;;667              //
;;;668              // Send out a one-byte ACK to ensure the byte goes back to the
;;;669              // host before we reset everything.
;;;670              //
;;;671              AckPacket();
00026a  f7fffffe          BL       AckPacket
;;;672              //
;;;673              // Make sure that the ACK packet has been sent.
;;;674              //
;;;675              FlushData();
00026e  f7fffffe          BL       UARTFlush
;;;676              //
;;;677              // Perform a software reset request.  This will cause the
;;;678              // microcontroller to reset; no further code will be executed.
;;;679              //
;;;680              NVIC->APINT = (NVIC_APINT_VECTKEY |
000272  490f              LDR      r1,|L1.688|
000274  480d              LDR      r0,|L1.684|
000276  6008              STR      r0,[r1,#0]
                  |L1.632|
;;;681                             NVIC_APINT_SYSRESETREQ);
;;;682              //
;;;683              // The microcontroller should have reset, so this should never
;;;684              // be reached.  Just in case, loop forever.
;;;685              //
;;;686              while(1)
000278  e7fe              B        |L1.632|
                  |L1.634|
;;;687               {
;;;688               }
;;;689             }
;;;690            //
;;;691            // Just acknowledge the command and set the error to indicate that
;;;692            // a bad command was sent.
;;;693            //
;;;694            default:
;;;695             {
;;;696              //
;;;697              // Acknowledge that this command was received correctly.  This
;;;698              // does not indicate success, just that the command was
;;;699              // received.
;;;700              //
;;;701              AckPacket();
00027a  f7fffffe          BL       AckPacket
;;;702              //
;;;703              // Indicate that a bad comand was sent.
;;;704              //
;;;705              if(Board_Id==BOOT_EN[2])    //只有板号设定的表位回送数据
00027e  4808              LDR      r0,|L1.672|
000280  78b1              LDRB     r1,[r6,#2]  ; Board_Id
000282  3075              ADDS     r0,r0,#0x75
000284  6880              LDR      r0,[r0,#8]  ; BOOT_EN
000286  4288              CMP      r0,r1
000288  d194              BNE      |L1.436|
;;;706               g_ucStatus = COMMAND_RET_UNKNOWN_CMD;
00028a  2041              MOVS     r0,#0x41
00028c  7070              STRB     r0,[r6,#1]
00028e  e70c              B        |L1.170|
;;;707             
;;;708              //
;;;709              // Go back and wait for a new command.
;;;710              //
;;;711              break;
;;;712             }
;;;713           }
;;;714         }
;;;715    }
;;;716    //*****************************************************************************
                          ENDP

                  |L1.656|
                          DCD      0x400fe0c4
                  |L1.660|
                          DCD      ||.data||
                  |L1.664|
                          DCD      0x40004420
                  |L1.668|
                          DCD      0x4000c000
                  |L1.672|
                          DCD      ||.bss||+0x3
                  |L1.676|
                          DCD      0x400fd000
                  |L1.680|
                          DCD      0xa4420002
                  |L1.684|
                          DCD      0x05fa0004
                  |L1.688|
                          DCD      0xe000ed0c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_pulDataBuffer
                          %        120
                  BOOT_EN
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  Disp_Sts
000000  00                DCB      0x00
                  g_ucStatus
000001  00                DCB      0x00
                  Board_Id
000002  0000              DCB      0x00,0x00
                  g_ulTransferSize
                          DCD      0x00000000
                  g_ulTransferAddress
                          DCD      0x00000000
                  g_pucDataBuffer
                          DCD      0x00000000
