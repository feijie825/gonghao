; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -odisp.o --depend=disp.d --feedback=bootloader.fed --cpu=Cortex-M3 --apcs=interwork -O1 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\Luminary -D__MICROLIB --omf_browse=disp.crf Disp.C]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  SysCtlPeripheralEnable PROC
;;;23     *****************************************************************************/
;;;24     void SysCtlPeripheralEnable(u32 ulPeripheral)
000000  b530              PUSH     {r4,r5,lr}
;;;25     {
;;;26     	SYSCTL->RCGC[(SYSCTL_PERIPH_INDEX(ulPeripheral)<3)?\
;;;27     	              SYSCTL_PERIPH_INDEX(ulPeripheral):2] |=
000002  2202              MOVS     r2,#2
000004  f3c02103          UBFX     r1,r0,#8,#4
000008  4d3c              LDR      r5,|L1.252|
00000a  4613              MOV      r3,r2
00000c  2903              CMP      r1,#3
00000e  d200              BCS      |L1.18|
000010  460b              MOV      r3,r1
                  |L1.18|
000012  eb050383          ADD      r3,r5,r3,LSL #2
000016  f8d33100          LDR      r3,[r3,#0x100]
00001a  f04f0401          MOV      r4,#1
00001e  fa04f400          LSL      r4,r4,r0
000022  ea430304          ORR      r3,r3,r4
000026  d200              BCS      |L1.42|
000028  460a              MOV      r2,r1
                  |L1.42|
00002a  eb050082          ADD      r0,r5,r2,LSL #2
00002e  f8c03100          STR      r3,[r0,#0x100]
;;;28                      SYSCTL_PERIPH_MASK(ulPeripheral);
;;;29     }
000032  bd30              POP      {r4,r5,pc}
;;;30     /*****************************************************************************
                          ENDP

                  Reset_HD7279 PROC
;;;32     *****************************************************************************/
;;;33     void Reset_HD7279(void)
000034  b570              PUSH     {r4-r6,lr}
;;;34     {
;;;35         SSIDataLen(SSI0,SSI_CR0_DSS_8);	      //设置数据长度为8bit
000036  4c32              LDR      r4,|L1.256|
000038  2107              MOVS     r1,#7
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       SSIDataLen
;;;36         GPIOPinWrite(GPIOA,DISP_RST,0);       //复位管脚置0
000040  f04f2540          MOV      r5,#0x40004000
000044  2200              MOVS     r2,#0
000046  2110              MOVS     r1,#0x10
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       GPIOPinWrite
;;;37         Delay(625);                           //每个数延时160ns  延时100us
00004e  f2402071          MOV      r0,#0x271
000052  f7fffffe          BL       Delay
;;;38         GPIOPinWrite(GPIOA,DISP_RST,DISP_RST);//复位管脚置1
000056  2210              MOVS     r2,#0x10
000058  4611              MOV      r1,r2
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       GPIOPinWrite
;;;39         Delay(6250);                          //每个数延时160ns  延时1mS
000060  f641006a          MOV      r0,#0x186a
000064  f7fffffe          BL       Delay
;;;40         SSIDataPut(SSI0,LED_RESET);           //送数据  
000068  21a4              MOVS     r1,#0xa4
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       SSIDataPut
;;;41         Delay(62500);                         //每个数延时160ns  延时10mS
000070  e8bd4070          POP      {r4-r6,lr}
000074  f24f4024          MOV      r0,#0xf424
000078  f7ffbffe          B.W      Delay
;;;42     //    Disp_Data(LED_SEND_DATA_CODE2);       //复位并显示 按方式0译码(与原误差板译码方式相同     
;;;43     }
;;;44     /*****************************************************************************
                          ENDP

                  Disp_Data PROC
;;;61     *****************************************************************************/
;;;62     void Disp_Data(u8 Disp_Mode)
00007c  e92d41f0          PUSH     {r4-r8,lr}
;;;63     {
000080  4605              MOV      r5,r0
;;;64         u8 m;
;;;65         u16 t;
;;;66         SSIDataLen(SSI0,SSI_CR0_DSS_16);	  //设置数据长度为8bit
000082  4f1f              LDR      r7,|L1.256|
000084  210f              MOVS     r1,#0xf
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       SSIDataLen
;;;67         for(m=0;m<8;m++)
00008c  2400              MOVS     r4,#0
;;;68          {
;;;69           t=((Disp_Mode|m)<<8);
;;;70           if(Disp_Mode==LED_SEND_DATA_CODE2)
;;;71            {
;;;72             if((Disp_Buf[m]&0x7f)<sizeof(Disp_Code_Tab))
00008e  4e1d              LDR      r6,|L1.260|
                  |L1.144|
000090  ea450004          ORR      r0,r5,r4              ;69
000094  0200              LSLS     r0,r0,#8              ;69
000096  2d90              CMP      r5,#0x90              ;70
000098  d10b              BNE      |L1.178|
00009a  5d31              LDRB     r1,[r6,r4]
00009c  f001027f          AND      r2,r1,#0x7f
0000a0  2a1e              CMP      r2,#0x1e
0000a2  d202              BCS      |L1.170|
;;;73              t|=Disp_Code_Tab[Disp_Buf[m]&0x7f];
0000a4  4b18              LDR      r3,|L1.264|
0000a6  5c9a              LDRB     r2,[r3,r2]
0000a8  4310              ORRS     r0,r0,r2
                  |L1.170|
;;;74             else
;;;75              t|=Disp_Code_Tab[DISP_BLANK];
;;;76             t|=(Disp_Buf[m]&0x80);         //判断是否有小数点
0000aa  f0010180          AND      r1,r1,#0x80
0000ae  4301              ORRS     r1,r1,r0
0000b0  e001              B        |L1.182|
                  |L1.178|
;;;77            }
;;;78           else    
;;;79            t|=Disp_Buf[m];
0000b2  5d31              LDRB     r1,[r6,r4]
0000b4  4301              ORRS     r1,r1,r0
                  |L1.182|
;;;80           SSIDataPut(SSI0,t);
0000b6  4638              MOV      r0,r7
0000b8  f7fffffe          BL       SSIDataPut
0000bc  1c64              ADDS     r4,r4,#1              ;67
0000be  b2e4              UXTB     r4,r4                 ;67
0000c0  2c08              CMP      r4,#8                 ;67
0000c2  d3e5              BCC      |L1.144|
;;;81          }
;;;82     }
0000c4  e8bd81f0          POP      {r4-r8,pc}
;;;83     //显示引导状态
                          ENDP

                  Disp_Boot PROC
;;;84     void Disp_Boot(void)
0000c8  480e              LDR      r0,|L1.260|
;;;85     {
;;;86         Disp_Buf[0]=DISP_MINUS;              //负误差
0000ca  2114              MOVS     r1,#0x14
0000cc  7001              STRB     r1,[r0,#0]
;;;87         Disp_Buf[1]=DISP_MINUS;              //负误差
0000ce  7041              STRB     r1,[r0,#1]
;;;88         Disp_Buf[2]=DISP_b;                  //负误差
0000d0  2216              MOVS     r2,#0x16
0000d2  7082              STRB     r2,[r0,#2]
;;;89         Disp_Buf[3]=DISP_o;                  //负误差
0000d4  221b              MOVS     r2,#0x1b
0000d6  70c2              STRB     r2,[r0,#3]
;;;90         Disp_Buf[4]=DISP_o;                  //负误差
0000d8  7102              STRB     r2,[r0,#4]
;;;91         Disp_Buf[5]=DISP_t;                  //负误差
0000da  2219              MOVS     r2,#0x19
0000dc  7142              STRB     r2,[r0,#5]
;;;92         Disp_Buf[6]=DISP_MINUS;              //负误差
0000de  7181              STRB     r1,[r0,#6]
;;;93         Disp_Buf[7]=DISP_MINUS;              //负误差
0000e0  71c1              STRB     r1,[r0,#7]
;;;94         Disp_Data(LED_SEND_DATA_CODE2);      //按方式0译码(与原误差板译码方式相同)	
0000e2  2090              MOVS     r0,#0x90
0000e4  e7fe              B        Disp_Data
;;;95     }
;;;96     //显示空白状态
                          ENDP

                  Disp_Blank PROC
;;;97     void Disp_Blank(void)
0000e6  2000              MOVS     r0,#0
;;;98     {
;;;99         u8 n;
;;;100        for(n=0;n<8;n++)
;;;101         {
;;;102          Disp_Buf[n]=DISP_BLANK;            //显示空白	
0000e8  4a06              LDR      r2,|L1.260|
0000ea  2115              MOVS     r1,#0x15
                  |L1.236|
0000ec  5411              STRB     r1,[r2,r0]
0000ee  1c40              ADDS     r0,r0,#1              ;100
0000f0  b2c0              UXTB     r0,r0                 ;100
0000f2  2808              CMP      r0,#8                 ;100
0000f4  d3fa              BCC      |L1.236|
;;;103         }	
;;;104        Disp_Data(LED_SEND_DATA_CODE2);      //按方式0译码(与原误差板译码方式相同)	
0000f6  2090              MOVS     r0,#0x90
0000f8  e7fe              B        Disp_Data
;;;105    }
                          ENDP

0000fa  0000              DCW      0x0000
                  |L1.252|
                          DCD      0x400fe000
                  |L1.256|
                          DCD      0x40008000
                  |L1.260|
                          DCD      ||.data||
                  |L1.264|
                          DCD      ||.constdata||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  Disp_Code_Tab
000000  7e306d79          DCB      0x7e,0x30,0x6d,0x79
000004  335b5f70          DCB      0x33,0x5b,0x5f,0x70
000008  7f7b777f          DCB      0x7f,0x7b,0x77,0x7f
00000c  4e7e4f47          DCB      0x4e,0x7e,0x4f,0x47
000010  7b370e77          DCB      0x7b,0x37,0x0e,0x77
000014  01001f3d          DCB      0x01,0x00,0x1f,0x3d
000018  3e0f151d          DCB      0x3e,0x0f,0x15,0x1d
00001c  6776              DCB      0x67,0x76

                          AREA ||.data||, DATA, ALIGN=0

                  Disp_Buf
                          %        8
