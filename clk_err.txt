; generated by ARM C/C++ Compiler, RVCT4.0 [Build 728]
; commandline ArmCC [--debug -c --asm --interleave -oclk_err.o --depend=clk_err.d --feedback=DISP.fed --cpu=Cortex-M3 --apcs=interwork -O1 -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\Luminary -D__MICROLIB CLK_ERR.C]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Cal_Clk_Reload PROC
;;;21     ********************************************************/
;;;22     void Cal_Clk_Reload(u8 Sts)   
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;23     {
000004  b088              SUB      sp,sp,#0x20
;;;24         u32 m;
;;;25         float f;
;;;26         f=CLK_FREQ_SET;                      //设定频率
000006  48f8              LDR      r0,|L1.1000|
000008  6805              LDR      r5,[r0,#0]  ; CLK_FREQ_SET
;;;27         f*=CLK_MEA_TIME;                     //乘以测量时间 为需要计量的时钟脉冲个数
00000a  48f8              LDR      r0,|L1.1004|
00000c  7800              LDRB     r0,[r0,#0]  ; CLK_MEA_TIME
00000e  4680              MOV      r8,r0
000010  f7fffffe          BL       __aeabi_ui2f
000014  4629              MOV      r1,r5
000016  f7fffffe          BL       __aeabi_fmul
;;;28         m=(u32)(f+0.5);                      //四舍五入
00001a  f7fffffe          BL       __aeabi_f2d
00001e  a7f4              ADR      r7,|L1.1008|
000020  e9cd0102          STRD     r0,r1,[sp,#8]
000024  e9d72300          LDRD     r2,r3,[r7,#0]
000028  f7fffffe          BL       __aeabi_dadd
00002c  e9cd0100          STRD     r0,r1,[sp,#0]
000030  f7fffffe          BL       __aeabi_d2uiz
000034  4604              MOV      r4,r0
;;;29         if(m==0)                             //判断在设定的时间内是否有一个时钟脉冲
000036  b904              CBNZ     r4,|L1.58|
;;;30          m=1;                                
000038  2401              MOVS     r4,#1
                  |L1.58|
00003a  48eb              LDR      r0,|L1.1000|
00003c  f04f0a01          MOV      r10,#1
000040  6800              LDR      r0,[r0,#0]            ;26
;;;31         if(CLK_FREQ_SET<1)                   //频率小于1HZ 一秒计数小于1个
;;;32          {
;;;33           CLK_RELOAD_VAL=1;                  //设定时间内收到脉冲个数为1 
;;;34           CLK_RELOAD_TIME=m;                 //重装次数
;;;35          }
;;;36         else if(CLK_FREQ_SET<60000)          //频率小于60KHz                                
;;;37          {                                   
;;;38           CLK_RELOAD_VAL=(u16)(CLK_FREQ_SET+0.5);//重装值(分频系数)
000042  f7fffffe          BL       __aeabi_f2d
000046  e9cd1005          STRD     r1,r0,[sp,#0x14]      ;31
00004a  f8df93ac          LDR      r9,|L1.1016|
00004e  4eeb              LDR      r6,|L1.1020|
000050  f1b55f7e          CMP      r5,#0x3f800000        ;31
000054  da04              BGE      |L1.96|
000056  f8a6a000          STRH     r10,[r6,#0]           ;33
00005a  f8a94000          STRH     r4,[r9,#0]            ;34
00005e  e01b              B        |L1.152|
                  |L1.96|
000060  48e7              LDR      r0,|L1.1024|
000062  4285              CMP      r5,r0                 ;36
000064  da11              BGE      |L1.138|
000066  e9dd0105          LDRD     r0,r1,[sp,#0x14]
00006a  e9cd1002          STRD     r1,r0,[sp,#8]
00006e  e9d72300          LDRD     r2,r3,[r7,#0]
000072  4601              MOV      r1,r0
000074  9802              LDR      r0,[sp,#8]
000076  f7fffffe          BL       __aeabi_dadd
00007a  e9cd0100          STRD     r0,r1,[sp,#0]
00007e  f7fffffe          BL       __aeabi_d2uiz
000082  8030              STRH     r0,[r6,#0]
;;;39           CLK_RELOAD_TIME=CLK_MEA_TIME;      //重装次数        
000084  f8a98000          STRH     r8,[r9,#0]
000088  e006              B        |L1.152|
                  |L1.138|
;;;40          } 
;;;41         else                                 //每秒计数超过最大分频值
;;;42          {                                   
;;;43           CLK_RELOAD_VAL=60000;              //重装值(分频系数)
00008a  f64e2060          MOV      r0,#0xea60
00008e  8030              STRH     r0,[r6,#0]
;;;44           CLK_RELOAD_TIME=(m/60000);         //重装次数
000090  fbb4f0f0          UDIV     r0,r4,r0
000094  f8a90000          STRH     r0,[r9,#0]
                  |L1.152|
;;;45          }                                   
;;;46         CLK_RELOAD_Cnt=CLK_RELOAD_TIME;      //当前重装计数
000098  48da              LDR      r0,|L1.1028|
00009a  f8b94000          LDRH     r4,[r9,#0]  ; CLK_RELOAD_TIME
00009e  8004              STRH     r4,[r0,#0]
;;;47         STD_CLK_VAL_ONE=STD_CLK_FREQ;        //标准时钟频率
0000a0  a0da              ADR      r0,|L1.1036|
0000a2  e9d08900          LDRD     r8,r9,[r0,#0]
0000a6  f8dfb360          LDR      r11,|L1.1032|
;;;48         STD_CLK_VAL_ONE*=CLK_RELOAD_VAL;     //分频值
0000aa  8830              LDRH     r0,[r6,#0]  ; CLK_RELOAD_VAL
0000ac  9004              STR      r0,[sp,#0x10]
0000ae  f7fffffe          BL       __aeabi_ui2d
0000b2  464b              MOV      r3,r9
0000b4  4642              MOV      r2,r8
0000b6  e9cd0102          STRD     r0,r1,[sp,#8]
0000ba  f7fffffe          BL       __aeabi_dmul
0000be  4680              MOV      r8,r0
0000c0  4689              MOV      r9,r1
0000c2  e9cb0100          STRD     r0,r1,[r11,#0]
;;;49         STD_CLK_VAL_SUM=STD_CLK_VAL_ONE*CLK_RELOAD_TIME;//总标准脉冲数
0000c6  4620              MOV      r0,r4
0000c8  f7fffffe          BL       __aeabi_ui2d
0000cc  464b              MOV      r3,r9
0000ce  4642              MOV      r2,r8
0000d0  e9cd0102          STRD     r0,r1,[sp,#8]
0000d4  f7fffffe          BL       __aeabi_dmul
0000d8  4ace              LDR      r2,|L1.1044|
0000da  c203              STM      r2!,{r0,r1}
;;;50         f=STD_CLK_VAL_ONE/CLK_FREQ_SET;      //每个时钟脉冲内应计的标准时钟脉冲数
0000dc  e9dd1005          LDRD     r1,r0,[sp,#0x14]
0000e0  e9cd0102          STRD     r0,r1,[sp,#8]
0000e4  460b              MOV      r3,r1
0000e6  4602              MOV      r2,r0
0000e8  4649              MOV      r1,r9
0000ea  4640              MOV      r0,r8
0000ec  f7fffffe          BL       __aeabi_ddiv
0000f0  e9cd0100          STRD     r0,r1,[sp,#0]
0000f4  f7fffffe          BL       __aeabi_d2f
;;;51         CLK_STB_RNG=(f/1000+0.5);            //0.1% 判断时钟脉冲是否稳定用
0000f8  4cc7              LDR      r4,|L1.1048|
0000fa  4621              MOV      r1,r4
0000fc  f7fffffe          BL       __aeabi_fdiv
000100  f7fffffe          BL       __aeabi_f2d
000104  e9cd0102          STRD     r0,r1,[sp,#8]
000108  cf0c              LDM      r7!,{r2,r3}
00010a  f7fffffe          BL       __aeabi_dadd
00010e  e9cd0100          STRD     r0,r1,[sp,#0]
000112  f7fffffe          BL       __aeabi_d2uiz
000116  49c1              LDR      r1,|L1.1052|
000118  b280              UXTH     r0,r0
00011a  8008              STRH     r0,[r1,#0]
;;;52         if(CLK_STB_RNG<50)
00011c  2832              CMP      r0,#0x32
00011e  d201              BCS      |L1.292|
;;;53          CLK_STB_RNG=50;                     //最小50个脉冲 50/1000000=50us
000120  2032              MOVS     r0,#0x32
000122  8008              STRH     r0,[r1,#0]
                  |L1.292|
;;;54     //计算中断间隔时间 超时时间
;;;55         f=CLK_RELOAD_VAL;                    //时钟分频值
000124  9804              LDR      r0,[sp,#0x10]
000126  f7fffffe          BL       __aeabi_ui2f
;;;56         f*=1000;                             //转化为ms
00012a  4621              MOV      r1,r4
00012c  f7fffffe          BL       __aeabi_fmul
;;;57         f/=CLK_FREQ_SET;                     //中断时间
000130  4629              MOV      r1,r5
000132  f7fffffe          BL       __aeabi_fdiv
;;;58         if(f<20)                             //中断不低于20ms 测量频率不大于3M
000136  49ba              LDR      r1,|L1.1056|
000138  4288              CMP      r0,r1
00013a  da00              BGE      |L1.318|
;;;59          f=20;
00013c  4608              MOV      r0,r1
                  |L1.318|
;;;60         CLK_Timer_Max=f+500;                 //超过设定时间0.5S 
00013e  49b9              LDR      r1,|L1.1060|
000140  f7fffffe          BL       __aeabi_fadd
000144  f7fffffe          BL       __aeabi_f2uiz
000148  49b7              LDR      r1,|L1.1064|
00014a  6008              STR      r0,[r1,#0]  ; CLK_Timer_Max
;;;61         FIRST_CLK_PLS=1;                     //重新测量
00014c  48b7              LDR      r0,|L1.1068|
00014e  f8c0a000          STR      r10,[r0,#0]  ; FIRST_CLK_PLS
;;;62         CLK_Timer=0;                         //重置定时器
000152  49b7              LDR      r1,|L1.1072|
000154  2000              MOVS     r0,#0
000156  6008              STR      r0,[r1,#0]  ; CLK_Timer
;;;63         if(Sts) 
000158  9808              LDR      r0,[sp,#0x20]
00015a  2800              CMP      r0,#0
00015c  d010              BEQ      |L1.384|
;;;64          {
;;;65           TimerDisable(TIMER1,TIMER_CTL_TAEN);        //Timer1-A禁能
00015e  4cb5              LDR      r4,|L1.1076|
000160  2101              MOVS     r1,#1
000162  4620              MOV      r0,r4
000164  f7fffffe          BL       TimerDisable
;;;66           TimerLoadSet(TIMER1,TIMER_A,CLK_RELOAD_VAL);//设置重装值
000168  8832              LDRH     r2,[r6,#0]  ; CLK_RELOAD_VAL
00016a  21ff              MOVS     r1,#0xff
00016c  4620              MOV      r0,r4
00016e  f7fffffe          BL       TimerLoadSet
;;;67           TimerEnable(TIMER1,TIMER_CTL_TAEN);         //Timer1-A启动
000172  4620              MOV      r0,r4
000174  b009              ADD      sp,sp,#0x24
000176  e8bd4ff0          POP      {r4-r11,lr}
00017a  2101              MOVS     r1,#1
00017c  f7ffbffe          B.W      TimerEnable
                  |L1.384|
;;;68          }
;;;69     }
000180  b009              ADD      sp,sp,#0x24
000182  e8bd8ff0          POP      {r4-r11,pc}
;;;70     /********************************************************
                          ENDP

                  Set_MTR_LCT_Com PROC
;;;73     ********************************************************/
;;;74     void Set_MTR_LCT_Com(u8 Com) 
000186  b082              SUB      sp,sp,#8
;;;75     {
;;;76         UART_SET Uart_Set;
;;;77         if(Com>LCTCOM)                        //判断端口设置是否合法
000188  2801              CMP      r0,#1
00018a  d837              BHI      |L1.508|
;;;78          return;
;;;79         memcpy(&Uart_Set,
00018c  49aa              LDR      r1,|L1.1080|
00018e  6809              LDR      r1,[r1,#0]  ; CAN_MSG_IPtr
000190  6889              LDR      r1,[r1,#8]
000192  9101              STR      r1,[sp,#4]
;;;80                &CAN_MSG_IPtr->Data.BYTE,
;;;81                4);
;;;82         if(Uart_Set.STOP>1)                   //判断停止位是否大于1
000194  f3c15281          UBFX     r2,r1,#22,#2
000198  2a01              CMP      r2,#1
00019a  d905              BLS      |L1.424|
;;;83          Uart_Set.STOP=1;
00019c  f4210140          BIC      r1,r1,#0xc00000
0001a0  f5010180          ADD      r1,r1,#0x400000
0001a4  9101              STR      r1,[sp,#4]
0001a6  e002              B        |L1.430|
                  |L1.424|
;;;84         else
;;;85          Uart_Set.STOP=0;
0001a8  f4210140          BIC      r1,r1,#0xc00000
0001ac  9101              STR      r1,[sp,#4]
                  |L1.430|
;;;86         if(Uart_Set.LEN>UART_8_BIT)          //判断是否设置错误
0001ae  9901              LDR      r1,[sp,#4]
0001b0  f3c14283          UBFX     r2,r1,#18,#4
0001b4  2a03              CMP      r2,#3
0001b6  d904              BLS      |L1.450|
;;;87          Uart_Set.LEN=UART_8_BIT;            //数据位数 默认8位
0001b8  f4211170          BIC      r1,r1,#0x3c0000
0001bc  f5012140          ADD      r1,r1,#0xc0000
0001c0  9101              STR      r1,[sp,#4]
                  |L1.450|
;;;88         if(Uart_Set.PARITY>UART_S_PARITY)
0001c2  9901              LDR      r1,[sp,#4]
0001c4  f3c16202          UBFX     r2,r1,#24,#3
0001c8  2a04              CMP      r2,#4
0001ca  d904              BLS      |L1.470|
;;;89          Uart_Set.PARITY=UART_E_PARITY;      //设置错误按偶校验
0001cc  f02161e0          BIC      r1,r1,#0x7000000
0001d0  f1017100          ADD      r1,r1,#0x2000000
0001d4  9101              STR      r1,[sp,#4]
                  |L1.470|
;;;90         if((Uart_Set.BAUD<MIN_BAUD)||
0001d6  9901              LDR      r1,[sp,#4]
0001d8  4b98              LDR      r3,|L1.1084|
0001da  f3c10211          UBFX     r2,r1,#0,#18
0001de  3a6e              SUBS     r2,r2,#0x6e
0001e0  429a              CMP      r2,r3
0001e2  d304              BCC      |L1.494|
;;;91            (Uart_Set.BAUD>MAX_BAUD))
;;;92          Uart_Set.BAUD=1200;                 //默认波特率	 	      	  
0001e4  f36f0111          BFC      r1,#0,#18
0001e8  f5016196          ADD      r1,r1,#0x4b0
0001ec  9101              STR      r1,[sp,#4]
                  |L1.494|
;;;93         memcpy(&Uart_Para[Com],
0001ee  4994              LDR      r1,|L1.1088|
0001f0  9a01              LDR      r2,[sp,#4]
0001f2  f8412020          STR      r2,[r1,r0,LSL #2]
;;;94                &Uart_Set,
;;;95                4);
;;;96         Init_Com(Com);
0001f6  b002              ADD      sp,sp,#8
0001f8  f7ffbffe          B.W      Init_Com
                  |L1.508|
;;;97     }
0001fc  b002              ADD      sp,sp,#8
0001fe  4770              BX       lr
;;;98     /********************************************************
                          ENDP

                  Set_Clk_Freq_Pr PROC
;;;100    ********************************************************/
;;;101    void Set_Clk_Freq_Pr(void)
000200  b570              PUSH     {r4-r6,lr}
;;;102    {
;;;103        float f;
;;;104        memcpy(&f,
000202  488d              LDR      r0,|L1.1080|
000204  6800              LDR      r0,[r0,#0]  ; CAN_MSG_IPtr
000206  6884              LDR      r4,[r0,#8]
;;;105               &CAN_MSG_IPtr->Data.BYTE,
;;;106               4);
;;;107        if((f==0)||                                //判断是否合法
;;;108           (f==CLK_FREQ_SET))                      //判断时钟频率是否改变
000208  4d77              LDR      r5,|L1.1000|
00020a  f0144fff          TST      r4,#0x7f800000        ;107
00020e  d009              BEQ      |L1.548|
000210  4620              MOV      r0,r4
000212  6829              LDR      r1,[r5,#0]  ; CLK_FREQ_SET
000214  f7fffffe          BL       __aeabi_cfcmpeq
000218  d004              BEQ      |L1.548|
;;;109         return;
;;;110        CLK_FREQ_SET=f;                            //更新时钟频率
00021a  602c              STR      r4,[r5,#0]  ; CLK_FREQ_SET
;;;111        Cal_Clk_Reload(1);                         //重新计算时钟频率重装值和重装次数 重装    
00021c  e8bd4070          POP      {r4-r6,lr}
000220  2001              MOVS     r0,#1
000222  e7fe              B        Cal_Clk_Reload
                  |L1.548|
;;;112    }           
000224  bd70              POP      {r4-r6,pc}
;;;113    /********************************************************
                          ENDP

                  Set_Clk_Time_Pr PROC
;;;115    ********************************************************/
;;;116    void Set_Clk_Time_Pr(void) 
000226  4884              LDR      r0,|L1.1080|
;;;117    {
;;;118        u8 m;
;;;119        m=CAN_MSG_IPtr->Data.BYTE[0];              //时钟频率测量时间 
000228  6800              LDR      r0,[r0,#0]  ; CAN_MSG_IPtr
00022a  7a00              LDRB     r0,[r0,#8]
;;;120        if(m<6)                                    //判断测量时间设置是否太小 小于6s  
00022c  2806              CMP      r0,#6
00022e  d201              BCS      |L1.564|
;;;121         m=6;                                                                         
000230  2006              MOVS     r0,#6
000232  e002              B        |L1.570|
                  |L1.564|
;;;122        else if(m>250)                             //判断测量时间设置是否太大 大于250s
000234  28fa              CMP      r0,#0xfa
000236  d900              BLS      |L1.570|
;;;123         m=250;
000238  20fa              MOVS     r0,#0xfa
                  |L1.570|
;;;124        if(m==CLK_MEA_TIME)                        //判断测量时间是否改变
00023a  496c              LDR      r1,|L1.1004|
00023c  7809              LDRB     r1,[r1,#0]  ; CLK_MEA_TIME
00023e  4288              CMP      r0,r1
000240  d001              BEQ      |L1.582|
;;;125         return;	     
;;;126        Cal_Clk_Reload(1);                         //重新计算时钟频率重装值和重装次数 重装    
000242  2001              MOVS     r0,#1
000244  e7fe              B        Cal_Clk_Reload
                  |L1.582|
;;;127    }           
000246  4770              BX       lr
;;;128    /********************************************************
                          ENDP

                  Set_Clk_Ctl_Pr PROC
;;;133    ********************************************************/
;;;134    void Set_Clk_Ctl_Pr(void)            
000248  487b              LDR      r0,|L1.1080|
;;;135    {
;;;136        u8 m;
;;;137        m=CAN_MSG_IPtr->Data.BYTE[0];              //时钟频率测量控制 
00024a  6800              LDR      r0,[r0,#0]  ; CAN_MSG_IPtr
00024c  7a00              LDRB     r0,[r0,#8]
;;;138        if(m==CLK_MEA_CTL)                         //测量控制是否改变
00024e  497d              LDR      r1,|L1.1092|
000250  780a              LDRB     r2,[r1,#0]  ; CLK_MEA_CTL
000252  4290              CMP      r0,r2
000254  d014              BEQ      |L1.640|
;;;139         return;                                   //设置非法退出
;;;140        if((m==MEA_STOP)||                         //停止测量和上传
000256  2830              CMP      r0,#0x30
000258  d003              BEQ      |L1.610|
;;;141           (m==MEA_NOTX)||                         //测量不上传
00025a  2831              CMP      r0,#0x31
00025c  d001              BEQ      |L1.610|
;;;142           (m==MEA_ORDER))                         //正常测量上传
00025e  2832              CMP      r0,#0x32
000260  d10e              BNE      |L1.640|
                  |L1.610|
;;;143         {	 
;;;144          CLK_MEA_CTL=m;                           //更新测量控制
000262  7008              STRB     r0,[r1,#0]
;;;145          if(CLK_MEA_CTL==0)                       //不在测量状态
000264  7808              LDRB     r0,[r1,#0]  ; CLK_MEA_CTL
000266  2800              CMP      r0,#0
000268  d00a              BEQ      |L1.640|
;;;146           return;
;;;147          if(MFClk_Mode==UNION_PLS)                //是否为联合脉冲
00026a  4877              LDR      r0,|L1.1096|
00026c  7800              LDRB     r0,[r0,#0]  ; MFClk_Mode
00026e  2831              CMP      r0,#0x31
000270  d103              BNE      |L1.634|
;;;148           if(MFClk_Type!=SZCLK_PLS)               //是否设置不为测量时钟脉冲
000272  4876              LDR      r0,|L1.1100|
000274  7800              LDRB     r0,[r0,#0]  ; MFClk_Type
000276  2831              CMP      r0,#0x31
000278  d102              BNE      |L1.640|
                  |L1.634|
;;;149            return;                                //是否为独立脉冲
;;;150          FIRST_CLK_PLS=1;                         //重新测量   
00027a  496c              LDR      r1,|L1.1068|
00027c  2001              MOVS     r0,#1
00027e  6008              STR      r0,[r1,#0]  ; FIRST_CLK_PLS
                  |L1.640|
;;;151         } 
;;;152    }           
000280  4770              BX       lr
;;;153    /********************************************************
                          ENDP

                  Set_XuL_Ctl_Pr PROC
;;;158    ********************************************************/
;;;159    void Set_XuL_Ctl_Pr(void)            
000282  486d              LDR      r0,|L1.1080|
;;;160    {
;;;161        u8 m;
;;;162        m=CAN_MSG_IPtr->Data.BYTE[0];              //需量周期测量控制
000284  6800              LDR      r0,[r0,#0]  ; CAN_MSG_IPtr
000286  7a00              LDRB     r0,[r0,#8]
;;;163        if(m==XUL_MEA_CTL)                         //测量控制是否改变
000288  4971              LDR      r1,|L1.1104|
00028a  780a              LDRB     r2,[r1,#0]  ; XUL_MEA_CTL
00028c  4290              CMP      r0,r2
00028e  d014              BEQ      |L1.698|
;;;164         return;                                   //设置非法退出
;;;165        if((m==MEA_STOP)||                         //停止测量和上传
000290  2830              CMP      r0,#0x30
000292  d003              BEQ      |L1.668|
;;;166           (m==MEA_NOTX)||                         //测量不上传
000294  2831              CMP      r0,#0x31
000296  d001              BEQ      |L1.668|
;;;167           (m==MEA_ORDER))                         //正常测量上传
000298  2832              CMP      r0,#0x32
00029a  d10e              BNE      |L1.698|
                  |L1.668|
;;;168         {	 
;;;169          XUL_MEA_CTL=m;                             //更新测量控制
00029c  7008              STRB     r0,[r1,#0]
;;;170          if(XUL_MEA_CTL==0)                         //原先不在测量状态
00029e  7808              LDRB     r0,[r1,#0]  ; XUL_MEA_CTL
0002a0  2800              CMP      r0,#0
0002a2  d00a              BEQ      |L1.698|
;;;171           return;
;;;172          if(MFClk_Mode==UNION_PLS)                  //是否为联合脉冲
0002a4  4868              LDR      r0,|L1.1096|
0002a6  7800              LDRB     r0,[r0,#0]  ; MFClk_Mode
0002a8  2831              CMP      r0,#0x31
0002aa  d103              BNE      |L1.692|
;;;173           if(MFClk_Type!=XULCLK_PLS)             	 //是否设置不为测量需量脉冲
0002ac  4867              LDR      r0,|L1.1100|
0002ae  7800              LDRB     r0,[r0,#0]  ; MFClk_Type
0002b0  2832              CMP      r0,#0x32
0002b2  d102              BNE      |L1.698|
                  |L1.692|
;;;174            return;                                  //是否为独立脉冲
;;;175          FIRST_XUL_PLS=1;                           //重新测量
0002b4  4967              LDR      r1,|L1.1108|
0002b6  2001              MOVS     r0,#1
0002b8  6008              STR      r0,[r1,#0]  ; FIRST_XUL_PLS
                  |L1.698|
;;;176         } 
;;;177    }           
0002ba  4770              BX       lr
;;;178    /********************************************************
                          ENDP

                  Set_XuL_Pls_Num PROC
;;;180    ********************************************************/
;;;181    void Set_XuL_Pls_Num(void)   
0002bc  485e              LDR      r0,|L1.1080|
;;;182    {
;;;183        u8 m;
;;;184        m=CAN_MSG_IPtr->Data.BYTE[0];              //需量周期测量个数 
0002be  6800              LDR      r0,[r0,#0]  ; CAN_MSG_IPtr
0002c0  7a00              LDRB     r0,[r0,#8]
;;;185        if(m==0)                                   //需量周期测量脉冲个数不能为0
0002c2  b908              CBNZ     r0,|L1.712|
;;;186         m=1;	                                     
0002c4  2001              MOVS     r0,#1
0002c6  e002              B        |L1.718|
                  |L1.712|
;;;187        else if(m>100)                             //需量周期测量脉冲个数不能大于100
0002c8  2864              CMP      r0,#0x64
0002ca  d900              BLS      |L1.718|
;;;188         m=100;	 
0002cc  2064              MOVS     r0,#0x64
                  |L1.718|
;;;189        if(m==XUL_RELOAD_TIME)                     //判断是否改变
0002ce  4962              LDR      r1,|L1.1112|
0002d0  780a              LDRB     r2,[r1,#0]  ; XUL_RELOAD_TIME
0002d2  4290              CMP      r0,r2
0002d4  d00b              BEQ      |L1.750|
;;;190         return;	
;;;191        XUL_RELOAD_TIME=m;                         //更新需量设定脉冲数
0002d6  7008              STRB     r0,[r1,#0]
;;;192        if(MFClk_Mode==UNION_PLS)                  //是否为联合脉冲
0002d8  485b              LDR      r0,|L1.1096|
0002da  7800              LDRB     r0,[r0,#0]  ; MFClk_Mode
0002dc  2831              CMP      r0,#0x31
0002de  d103              BNE      |L1.744|
;;;193         if(MFClk_Type!=XULCLK_PLS)             	 //是否设置不为测量需量脉冲
0002e0  485a              LDR      r0,|L1.1100|
0002e2  7800              LDRB     r0,[r0,#0]  ; MFClk_Type
0002e4  2832              CMP      r0,#0x32
0002e6  d102              BNE      |L1.750|
                  |L1.744|
;;;194          return;                                  //是否为独立脉冲
;;;195        FIRST_XUL_PLS=1;                           //重新测量 
0002e8  495a              LDR      r1,|L1.1108|
0002ea  2001              MOVS     r0,#1
0002ec  6008              STR      r0,[r1,#0]  ; FIRST_XUL_PLS
                  |L1.750|
;;;196    }  
0002ee  4770              BX       lr
;;;197    /********************************************************
                          ENDP

                  Set_Disp_Mode PROC
;;;204    ********************************************************/
;;;205    void Set_Disp_Mode(void)
0002f0  4851              LDR      r0,|L1.1080|
;;;206    {
;;;207        u8 m;
;;;208        m=CAN_MSG_IPtr->Data.BYTE[0];              //设置显示模式
0002f2  6800              LDR      r0,[r0,#0]  ; CAN_MSG_IPtr
0002f4  7a00              LDRB     r0,[r0,#8]
;;;209        if((m>3)||                                 //判断设置是否非法
0002f6  2803              CMP      r0,#3
0002f8  d804              BHI      |L1.772|
;;;210           (m==Disp_Choose))                       //判断显示方式是否改变    	
0002fa  4958              LDR      r1,|L1.1116|
0002fc  780a              LDRB     r2,[r1,#0]  ; Disp_Choose
0002fe  4290              CMP      r0,r2
000300  d000              BEQ      |L1.772|
;;;211         return;
;;;212        Disp_Choose=m;                             //更新显示方式
000302  7008              STRB     r0,[r1,#0]
                  |L1.772|
;;;213    }    
000304  4770              BX       lr
;;;214    /******************************************************
                          ENDP

                  Set_Reload_MtrD PROC
;;;217    ******************************************************/
;;;218    void Set_Reload_MtrD(void)
000306  4856              LDR      r0,|L1.1120|
;;;219    {
;;;220        if(Com_Tx_Sts[MTRCOM]!=COM_TX_NO)     //发送缓冲区不在空闲状态 退出
000308  7801              LDRB     r1,[r0,#0]  ; Com_Tx_Sts
00030a  2900              CMP      r1,#0
00030c  d108              BNE      |L1.800|
;;;221         return;
;;;222        if(Com_OHead[MTRCOM]!=0)              //发送缓冲区收到过有效数据
00030e  4955              LDR      r1,|L1.1124|
000310  8809              LDRH     r1,[r1,#0]  ; Com_OHead
000312  2900              CMP      r1,#0
000314  d004              BEQ      |L1.800|
;;;223         {
;;;224          Com_OTail[MTRCOM]=0;
000316  4a54              LDR      r2,|L1.1128|
000318  2100              MOVS     r1,#0
00031a  8011              STRH     r1,[r2,#0]
;;;225          Com_Tx_Sts[MTRCOM]=COM_TX_EN;       //发送缓冲区有效     	
00031c  2145              MOVS     r1,#0x45
00031e  7001              STRB     r1,[r0,#0]
                  |L1.800|
;;;226         }	 
;;;227    }
000320  4770              BX       lr
;;;228    /******************************************************
                          ENDP

                  Set_Reload_LctD PROC
;;;231    ******************************************************/
;;;232    void Set_Reload_LctD(void)
000322  484f              LDR      r0,|L1.1120|
;;;233    {
;;;234        if(Com_Tx_Sts[LCTCOM]!=COM_TX_NO)     //发送缓冲区不在空闲状态 退出
000324  7841              LDRB     r1,[r0,#1]  ; Com_Tx_Sts
000326  2900              CMP      r1,#0
000328  d108              BNE      |L1.828|
;;;235         return;
;;;236        if(Com_OHead[LCTCOM]!=0)              //发送缓冲区收到过有效数据
00032a  494e              LDR      r1,|L1.1124|
00032c  8849              LDRH     r1,[r1,#2]  ; Com_OHead
00032e  2900              CMP      r1,#0
000330  d004              BEQ      |L1.828|
;;;237         {
;;;238          Com_OTail[LCTCOM]=0;
000332  4a4d              LDR      r2,|L1.1128|
000334  2100              MOVS     r1,#0
000336  8051              STRH     r1,[r2,#2]
;;;239          Com_Tx_Sts[LCTCOM]=COM_TX_EN;       //发送缓冲区有效     	
000338  2145              MOVS     r1,#0x45
00033a  7041              STRB     r1,[r0,#1]
                  |L1.828|
;;;240         }	 
;;;241    }
00033c  4770              BX       lr
;;;242    /******************************************************
                          ENDP

                  Set_ReTx_MtrD PROC
;;;245    ******************************************************/
;;;246    void Set_ReTx_MtrD(void)
00033e  484b              LDR      r0,|L1.1132|
;;;247    {
;;;248        if(Com_Rx_Sts[MTRCOM]!=COM_RX_NO)    //接收缓冲区不在空闲状态 退出
000340  7801              LDRB     r1,[r0,#0]  ; Com_Rx_Sts
000342  2900              CMP      r1,#0
000344  d108              BNE      |L1.856|
;;;249         return;                             //串口不在接收状态退出
;;;250        if(Com_IHead[MTRCOM]!=0)             //判断是否收到有效数据
000346  494a              LDR      r1,|L1.1136|
000348  8809              LDRH     r1,[r1,#0]  ; Com_IHead
00034a  2900              CMP      r1,#0
00034c  d004              BEQ      |L1.856|
;;;251         {	
;;;252          Com_ITail[MTRCOM]=0;               //发送处理指针清零
00034e  4a49              LDR      r2,|L1.1140|
000350  2100              MOVS     r1,#0
000352  8011              STRH     r1,[r2,#0]
;;;253          Com_Rx_Sts[MTRCOM]=COM_RX_END;     //接收结束状态 收到有效数据等待处理
000354  2145              MOVS     r1,#0x45
000356  7001              STRB     r1,[r0,#0]
                  |L1.856|
;;;254         } 
;;;255    }
000358  4770              BX       lr
;;;256    /******************************************************
                          ENDP

                  Set_ReTx_LctD PROC
;;;259    ******************************************************/
;;;260    void Set_ReTx_LctD(void)
00035a  4844              LDR      r0,|L1.1132|
;;;261    {
;;;262        if(Com_Rx_Sts[LCTCOM]!=COM_RX_NO)    //接收缓冲区不在空闲状态 退出
00035c  7841              LDRB     r1,[r0,#1]  ; Com_Rx_Sts
00035e  2900              CMP      r1,#0
000360  d108              BNE      |L1.884|
;;;263         return;                             //串口不在接收状态退出
;;;264        if(Com_IHead[LCTCOM]!=0)             //判断是否收到有效数据
000362  4943              LDR      r1,|L1.1136|
000364  8849              LDRH     r1,[r1,#2]  ; Com_IHead
000366  2900              CMP      r1,#0
000368  d004              BEQ      |L1.884|
;;;265         {	
;;;266          Com_ITail[LCTCOM]=0;               //发送处理指针清零
00036a  4a42              LDR      r2,|L1.1140|
00036c  2100              MOVS     r1,#0
00036e  8051              STRH     r1,[r2,#2]
;;;267          Com_Rx_Sts[LCTCOM]=COM_RX_END;     //接收结束状态 收到有效数据等待处理
000370  2145              MOVS     r1,#0x45
000372  7041              STRB     r1,[r0,#1]
                  |L1.884|
;;;268         } 
;;;269    }
000374  4770              BX       lr
;;;270    /******************************************************
                          ENDP

                  Set_Time_Base PROC
;;;273    ******************************************************/
;;;274    void Set_Time_Base(void)
000376  2000              MOVS     r0,#0
;;;275    {
;;;276        u8 m;
;;;277        for(m=0;m<8;m++)
;;;278         TIME_ASC[m]=CAN_MSG_IPtr->Data.BYTE[m]; //拷贝当前时间	
000378  4a2f              LDR      r2,|L1.1080|
00037a  493f              LDR      r1,|L1.1144|
00037c  6812              LDR      r2,[r2,#0]
                  |L1.894|
00037e  1813              ADDS     r3,r2,r0
000380  7a1b              LDRB     r3,[r3,#8]
000382  540b              STRB     r3,[r1,r0]
000384  1c40              ADDS     r0,r0,#1              ;277
000386  b2c0              UXTB     r0,r0                 ;277
000388  2808              CMP      r0,#8                 ;277
00038a  d3f8              BCC      |L1.894|
;;;279    }
00038c  4770              BX       lr
;;;280    /********************************************************
                          ENDP

                  Check_Std_Clk PROC
;;;282    ********************************************************/
;;;283    void Check_Std_Clk(void)      
00038e  483b              LDR      r0,|L1.1148|
;;;284    {
;;;285        if(STD_CLK_Timer<CHK_STD_CLK_TIME)
000390  7800              LDRB     r0,[r0,#0]  ; STD_CLK_Timer
000392  2832              CMP      r0,#0x32
000394  d302              BCC      |L1.924|
;;;286         return;
;;;287        NO_STD_CLK=1;                           //标准时钟脉冲不存在标志 
000396  493a              LDR      r1,|L1.1152|
000398  2001              MOVS     r0,#1
00039a  6008              STR      r0,[r1,#0]  ; NO_STD_CLK
                  |L1.924|
;;;288    }  
00039c  4770              BX       lr
;;;289    /********************************************************
                          ENDP

                  Act_Freq_to_Set PROC
;;;291    ********************************************************/
;;;292    void Act_Freq_to_Set(void)
00039e  e92d41ff          PUSH     {r0-r8,lr}
;;;293    {
;;;294        float f=1.0;
0003a2  f04f567e          MOV      r6,#0x3f800000
;;;295        for(;;)
;;;296         {
;;;297          if(CLK_NEW_ACT_FREQ>=10.0)
0003a6  4c39              LDR      r4,|L1.1164|
0003a8  a536              ADR      r5,|L1.1156|
                  |L1.938|
0003aa  e9d52300          LDRD     r2,r3,[r5,#0]
0003ae  e9d40100          LDRD     r0,r1,[r4,#0]
0003b2  f7fffffe          BL       __aeabi_cdrcmple
0003b6  d86b              BHI      |L1.1168|
;;;298           {
;;;299            CLK_NEW_ACT_FREQ/=10.0;            //转化成1到10之间的数 
0003b8  e9d52300          LDRD     r2,r3,[r5,#0]
0003bc  e9d40100          LDRD     r0,r1,[r4,#0]
0003c0  f7fffffe          BL       __aeabi_ddiv
0003c4  e9c40100          STRD     r0,r1,[r4,#0]
;;;300            f*=10.0;
0003c8  4630              MOV      r0,r6
0003ca  f7fffffe          BL       __aeabi_f2d
0003ce  e9cd0102          STRD     r0,r1,[sp,#8]
0003d2  e9d52300          LDRD     r2,r3,[r5,#0]
0003d6  f7fffffe          BL       __aeabi_dmul
0003da  e9cd0100          STRD     r0,r1,[sp,#0]
0003de  f7fffffe          BL       __aeabi_d2f
0003e2  4606              MOV      r6,r0
0003e4  e7e1              B        |L1.938|
0003e6  e053              B        |L1.1168|
                  |L1.1000|
                          DCD      CLK_FREQ_SET
                  |L1.1004|
                          DCD      CLK_MEA_TIME
                  |L1.1008|
0003f0  00000000          DCFD     0x3fe0000000000000 ; 0.5
0003f4  3fe00000
                  |L1.1016|
                          DCD      CLK_RELOAD_TIME
                  |L1.1020|
                          DCD      CLK_RELOAD_VAL
                  |L1.1024|
                          DCD      0x476a6000
                  |L1.1028|
                          DCD      CLK_RELOAD_Cnt
                  |L1.1032|
                          DCD      STD_CLK_VAL_ONE
                  |L1.1036|
00040c  00000000          DCFD     0x412e848000000000 ; 1000000
000410  412e8480
                  |L1.1044|
                          DCD      STD_CLK_VAL_SUM
                  |L1.1048|
                          DCD      0x447a0000
                  |L1.1052|
                          DCD      CLK_STB_RNG
                  |L1.1056|
                          DCD      0x41a00000
                  |L1.1060|
                          DCD      0x43fa0000
                  |L1.1064|
                          DCD      CLK_Timer_Max
                  |L1.1068|
                          DCD      FIRST_CLK_PLS
                  |L1.1072|
                          DCD      CLK_Timer
                  |L1.1076|
                          DCD      0x40031000
                  |L1.1080|
                          DCD      CAN_MSG_IPtr
                  |L1.1084|
                          DCD      0x0001c193
                  |L1.1088|
                          DCD      Uart_Para
                  |L1.1092|
                          DCD      CLK_MEA_CTL
                  |L1.1096|
                          DCD      MFClk_Mode
                  |L1.1100|
                          DCD      MFClk_Type
                  |L1.1104|
                          DCD      XUL_MEA_CTL
                  |L1.1108|
                          DCD      FIRST_XUL_PLS
                  |L1.1112|
                          DCD      XUL_RELOAD_TIME
                  |L1.1116|
                          DCD      Disp_Choose
                  |L1.1120|
                          DCD      Com_Tx_Sts
                  |L1.1124|
                          DCD      Com_OHead
                  |L1.1128|
                          DCD      Com_OTail
                  |L1.1132|
                          DCD      Com_Rx_Sts
                  |L1.1136|
                          DCD      Com_IHead
                  |L1.1140|
                          DCD      Com_ITail
                  |L1.1144|
                          DCD      TIME_ASC
                  |L1.1148|
                          DCD      STD_CLK_Timer
                  |L1.1152|
                          DCD      NO_STD_CLK
                  |L1.1156|
000484  00000000          DCFD     0x4024000000000000 ; 10
000488  40240000
                  |L1.1164|
                          DCD      CLK_NEW_ACT_FREQ
                  |L1.1168|
;;;301           }
;;;302          else if(CLK_NEW_ACT_FREQ<1.0)
000490  a0f9              ADR      r0,|L1.2168|
000492  c80c              LDM      r0!,{r2,r3}
000494  e9d40100          LDRD     r0,r1,[r4,#0]
000498  f7fffffe          BL       __aeabi_cdcmple
00049c  d216              BCS      |L1.1228|
;;;303           {
;;;304            CLK_NEW_ACT_FREQ*=10.0;
00049e  e9d52300          LDRD     r2,r3,[r5,#0]
0004a2  e9d40100          LDRD     r0,r1,[r4,#0]
0004a6  f7fffffe          BL       __aeabi_dmul
0004aa  e9c40100          STRD     r0,r1,[r4,#0]
;;;305            f/=10.0;
0004ae  4630              MOV      r0,r6
0004b0  f7fffffe          BL       __aeabi_f2d
0004b4  e9cd0102          STRD     r0,r1,[sp,#8]
0004b8  e9d52300          LDRD     r2,r3,[r5,#0]
0004bc  f7fffffe          BL       __aeabi_ddiv
0004c0  e9cd0100          STRD     r0,r1,[sp,#0]
0004c4  f7fffffe          BL       __aeabi_d2f
0004c8  4606              MOV      r6,r0
0004ca  e76e              B        |L1.938|
                  |L1.1228|
;;;306           } 
;;;307          else
;;;308           break; 
;;;309         }
;;;310        CLK_FREQ_SET=(u32)(CLK_NEW_ACT_FREQ*10000+0.5);//设定频率 按实际频率 0.005%化整
0004cc  a0ec              ADR      r0,|L1.2176|
0004ce  c80c              LDM      r0!,{r2,r3}
0004d0  6861              LDR      r1,[r4,#4]  ; CLK_NEW_ACT_FREQ
0004d2  6820              LDR      r0,[r4,#0]  ; CLK_NEW_ACT_FREQ
0004d4  460d              MOV      r5,r1
0004d6  4607              MOV      r7,r0
0004d8  f7fffffe          BL       __aeabi_dmul
0004dc  e9cd0102          STRD     r0,r1,[sp,#8]
0004e0  f2af00f4          ADR      r0,|L1.1008|
0004e4  c80c              LDM      r0!,{r2,r3}
0004e6  9802              LDR      r0,[sp,#8]
0004e8  f7fffffe          BL       __aeabi_dadd
0004ec  9000              STR      r0,[sp,#0]
0004ee  f7fffffe          BL       __aeabi_d2uiz
0004f2  f7fffffe          BL       __aeabi_ui2f
0004f6  f8df8390          LDR      r8,|L1.2184|
;;;311        CLK_FREQ_SET/=10000;                 //还原设定频率  
0004fa  49e4              LDR      r1,|L1.2188|
0004fc  f7fffffe          BL       __aeabi_fdiv
;;;312        CLK_FREQ_SET*=f;                     //
000500  4631              MOV      r1,r6
000502  f7fffffe          BL       __aeabi_fmul
000506  f8c80000          STR      r0,[r8,#0]  ; CLK_FREQ_SET
;;;313        CLK_NEW_ACT_FREQ*=f;                 //还原实际频率              
00050a  4630              MOV      r0,r6
00050c  f7fffffe          BL       __aeabi_f2d
000510  462b              MOV      r3,r5
000512  463a              MOV      r2,r7
000514  e9cd0102          STRD     r0,r1,[sp,#8]
000518  f7fffffe          BL       __aeabi_dmul
00051c  c403              STM      r4!,{r0,r1}
;;;314    }            
00051e  e8bd81ff          POP      {r0-r8,pc}
;;;315    /********************************************************
                          ENDP

                  Proc_Clk_OvTm PROC
;;;317    ********************************************************/
;;;318    void Proc_Clk_OvTm(void)       
000522  e92d41fc          PUSH     {r2-r8,lr}
;;;319    {
;;;320        if(NO_CLK_PLS)                          //判断是否检测到时钟脉冲标志
000526  4eda              LDR      r6,|L1.2192|
000528  6830              LDR      r0,[r6,#0]  ; NO_CLK_PLS
00052a  2800              CMP      r0,#0
00052c  d141              BNE      |L1.1458|
;;;321         return;                                //有时钟脉冲 
;;;322        if(CLK_Timer>=CLK_Timer_Max)            //超时未到 退出
00052e  49d9              LDR      r1,|L1.2196|
000530  48d9              LDR      r0,|L1.2200|
000532  680a              LDR      r2,[r1,#0]  ; CLK_Timer
000534  6800              LDR      r0,[r0,#0]  ; CLK_Timer_Max
000536  4282              CMP      r2,r0
000538  d33b              BCC      |L1.1458|
;;;323         {
;;;324          u16 m;
;;;325          CLK_Timer=0;                          //重置定时器
00053a  2200              MOVS     r2,#0
00053c  600a              STR      r2,[r1,#0]  ; CLK_Timer
;;;326          m=(u16)TIMER1->TAR;                   //时钟脉冲计数值
00053e  49d7              LDR      r1,|L1.2204|
000540  6c89              LDR      r1,[r1,#0x48]
;;;327          m=CLK_RELOAD_VAL-m;                   //实际计数值
000542  4ad7              LDR      r2,|L1.2208|
000544  8812              LDRH     r2,[r2,#0]  ; CLK_RELOAD_VAL
000546  1a51              SUBS     r1,r2,r1
000548  b28d              UXTH     r5,r1
;;;328          CLK_NEW_ACT_FREQ=1000;                //1S =1000ms
00054a  a1d7              ADR      r1,|L1.2216|
00054c  e9d17800          LDRD     r7,r8,[r1,#0]
000550  4cd4              LDR      r4,|L1.2212|
;;;329          CLK_NEW_ACT_FREQ/=CLK_Timer_Max;      //收到1个时钟脉冲时 时钟频率
000552  f7fffffe          BL       __aeabi_ui2d
000556  e9cd0100          STRD     r0,r1,[sp,#0]
00055a  460b              MOV      r3,r1
00055c  4602              MOV      r2,r0
00055e  4641              MOV      r1,r8
000560  4638              MOV      r0,r7
000562  f7fffffe          BL       __aeabi_ddiv
000566  4607              MOV      r7,r0
000568  4688              MOV      r8,r1
00056a  e9c40100          STRD     r0,r1,[r4,#0]
;;;330          if(m==0)                              //在规定时间内没有收到时钟脉冲
00056e  b94d              CBNZ     r5,|L1.1412|
;;;331           CLK_NEW_ACT_FREQ/=10;                //频率缩小10倍
000570  f2af00f0          ADR      r0,|L1.1156|
000574  c80c              LDM      r0!,{r2,r3}
000576  4641              MOV      r1,r8
000578  4638              MOV      r0,r7
00057a  f7fffffe          BL       __aeabi_ddiv
00057e  e9c40100          STRD     r0,r1,[r4,#0]
000582  e00a              B        |L1.1434|
                  |L1.1412|
;;;332          else
;;;333           CLK_NEW_ACT_FREQ*=m;                 //粗略频率
000584  4628              MOV      r0,r5
000586  f7fffffe          BL       __aeabi_ui2d
00058a  4643              MOV      r3,r8
00058c  463a              MOV      r2,r7
00058e  e9cd0100          STRD     r0,r1,[sp,#0]
000592  f7fffffe          BL       __aeabi_dmul
000596  e9c40100          STRD     r0,r1,[r4,#0]
                  |L1.1434|
;;;334          if(CLK_NEW_ACT_FREQ<0.0001)           //频率小于万分之一HZ 
00059a  a0c5              ADR      r0,|L1.2224|
00059c  c80c              LDM      r0!,{r2,r3}
00059e  cc03              LDM      r4!,{r0,r1}
0005a0  f7fffffe          BL       __aeabi_cdcmple
0005a4  d207              BCS      |L1.1462|
;;;335           {
;;;336            NO_CLK_PLS=1;                       //没有时钟脉冲标志
0005a6  2001              MOVS     r0,#1
0005a8  6030              STR      r0,[r6,#0]  ; NO_CLK_PLS
;;;337            CLK_FREQ_SET=1.0;                   //设置成默认值
0005aa  49b7              LDR      r1,|L1.2184|
0005ac  f04f507e          MOV      r0,#0x3f800000
0005b0  6008              STR      r0,[r1,#0]  ; CLK_FREQ_SET
                  |L1.1458|
;;;338           }
;;;339          else
;;;340           {
;;;341            Act_Freq_to_Set();                  //推算设定频率
;;;342            Cal_Clk_Reload(1);                  //自动调整测量重装值和重装次数
;;;343           } 
;;;344         } 
;;;345    }   
0005b2  e8bd81fc          POP      {r2-r8,pc}
                  |L1.1462|
0005b6  f7fffffe          BL       Act_Freq_to_Set
0005ba  e8bd41fc          POP      {r2-r8,lr}            ;342
0005be  2001              MOVS     r0,#1                 ;342
0005c0  e7fe              B        Cal_Clk_Reload
;;;346    /********************************************************
                          ENDP

                  MEA_CLK_FREQ PROC
;;;352    ********************************************************/
;;;353    void MEA_CLK_FREQ(void)      
0005c2  e92d5fff          PUSH     {r0-r12,lr}
;;;354    {
;;;355        if(WORK_MODE==MEA_ENG_DUTY_M)           //判断是否在测量脉冲周期
0005c6  48bc              LDR      r0,|L1.2232|
0005c8  7800              LDRB     r0,[r0,#0]  ; WORK_MODE
0005ca  280b              CMP      r0,#0xb
0005cc  d07e              BEQ      |L1.1740|
;;;356         return;                                //退出
;;;357        if(MFClk_Mode==UNION_PLS)               //判断脉冲是否为联合脉冲
0005ce  48bb              LDR      r0,|L1.2236|
0005d0  7800              LDRB     r0,[r0,#0]  ; MFClk_Mode
0005d2  2831              CMP      r0,#0x31
0005d4  d103              BNE      |L1.1502|
;;;358         if(MFClk_Type!=SZCLK_PLS)              //判断联合脉冲状态下 是否正在测量时钟脉冲
0005d6  48ba              LDR      r0,|L1.2240|
0005d8  7800              LDRB     r0,[r0,#0]  ; MFClk_Type
0005da  2831              CMP      r0,#0x31
0005dc  d176              BNE      |L1.1740|
                  |L1.1502|
;;;359          return;                               //不在测量时钟脉冲 退出		
;;;360        if(NEW_CLK_PLS)                         //收到新时钟脉冲(分频后脉冲)
0005de  48b9              LDR      r0,|L1.2244|
0005e0  6801              LDR      r1,[r0,#0]  ; NEW_CLK_PLS
0005e2  2900              CMP      r1,#0
0005e4  d072              BEQ      |L1.1740|
;;;361         {
;;;362          u32   Cnt;     
;;;363          float f;
;;;364          NEW_CLK_PLS=0;                        //清除收到新时钟脉冲标志
0005e6  2500              MOVS     r5,#0
0005e8  6005              STR      r5,[r0,#0]  ; NEW_CLK_PLS
;;;365          CLK_RELOAD_Cnt--;
0005ea  f8dfc2dc          LDR      r12,|L1.2248|
0005ee  f8bc0000          LDRH     r0,[r12,#0]  ; CLK_RELOAD_Cnt
0005f2  1e40              SUBS     r0,r0,#1
0005f4  b281              UXTH     r1,r0
0005f6  f8ac1000          STRH     r1,[r12,#0]
;;;366          if(CLK_RELOAD_Cnt==0)                 //判断设定分频计数是否到
;;;367           {  
;;;368            Cnt= NEW_CLK_Cnt-OLD_CLK_Cnt;       //实计脉冲数
;;;369            OLD_CLK_Cnt=NEW_CLK_Cnt;            //更新计数
;;;370            CLK_RELOAD_Cnt=CLK_RELOAD_TIME;     //重装计数值
0005fa  48b4              LDR      r0,|L1.2252|
;;;371            if(Cnt<10)                          //标准时钟脉冲计数值是否太小
;;;372             {
;;;373              NO_STD_CLK=1;                     //没有标准脉冲
0005fc  2401              MOVS     r4,#1
0005fe  8803              LDRH     r3,[r0,#0]            ;370
000600  4ab3              LDR      r2,|L1.2256|
;;;374              strcpy(TEMP_STR,
;;;375                     "No JZMC");
;;;376              Send_Data(ERR_OCMD_CLK_FRQ,       //回送没有晶振脉冲
;;;377                        7,                      
;;;378                        TEMP_STR);              //回送时钟频率
;;;379              Send_Data(ERR_OCMD_DAY_ERR,       //回送没有晶振脉冲
;;;380                        7,                      
;;;381                        TEMP_STR);              //回送时钟频率
;;;382              return;
;;;383             } 
;;;384            else
;;;385             {	 
;;;386              NO_STD_CLK=0;                       //有标准脉冲
;;;387              CLK_NEW_ACT_FREQ=STD_CLK_VAL_SUM;   //标准时钟脉冲数
;;;388              CLK_NEW_ACT_FREQ/=Cnt;              //计算出时钟频率 
;;;389              memset(CLK_FREQ_ASC,0,12);          //测量正确 计算日计时误差
;;;390              sprintf(CLK_FREQ_ASC,               //输出时钟频率ASC缓冲区  返回输出数据长度
;;;391                          "%12.10f",              //长整型数据 数据最长12位 最大10位小数
;;;392                          CLK_NEW_ACT_FREQ);      //实测时钟频率
;;;393              CLK_DAY_ERR= CLK_NEW_ACT_FREQ;      //实测频率 日计时误差 =(86400*实测晶振频率)/标定晶振频率-86400
;;;394              CLK_DAY_ERR/=CLK_FREQ_SET;          //                    =(实测频率/标定频率-1)*86400) 
;;;395              CLK_DAY_ERR-=1;                     //
;;;396              CLK_DAY_ERR*=86400;                 //计算出日计时误差
;;;397              sprintf(DAY_ERR_ASC,                //输出时钟频率ASC缓冲区  返回输出数据长度
;;;398                          "%8.6f",                //长整型数据 数据最长7位 最大6位小数
;;;399                          CLK_DAY_ERR);           //日计时误差
;;;400              NEW_CLK_DATA=1;                     //有新数据标志
;;;401              if(Disp_Choose==DISP_CLK_FREQ)      //判断是否显示时钟频率
;;;402               {
;;;403                Disp_Buf[0]=DISP_F;                //显示'F'
;;;404                Copy_Str_To_DSBUF(DISP_FREQ_LEN,   //时钟频率数据长度
;;;405                                  DISP_FREQ_OFFSET,//时钟频率显示偏移量
;;;406                                  CLK_FREQ_ASC);   //时钟频率ASC地址   
;;;407               
;;;408               }
;;;409              else if(Disp_Choose==DISP_DAY_ERR)  //判断是否显示日计时误差
;;;410               {  
;;;411                Disp_Buf[0]=DISP_d;               //显示'd'
;;;412                Disp_Buf[1]=DISP_BLANK;           //显示空
;;;413                Copy_Str_To_DSBUF(DISP_DAY_LEN,   //日计时误差数据长度
;;;414                                  DISP_DAY_OFFSET,//日计时误差显示偏移量
;;;415                                  DAY_ERR_ASC);   //日计时误差ASC地址 
;;;416               }
;;;417             }
;;;418            if(CLK_FREQ_ASC[7]=='.')              //时钟频率>=1000000Hz 回送7位数据
;;;419             Send_Data(ERR_OCMD_CLK_FRQ,          //回送脉冲周期命令
;;;420                       7,                         
;;;421                       CLK_FREQ_ASC);             //回送时钟频率
;;;422            else        	                        
;;;423             Send_Data(ERR_OCMD_CLK_FRQ,          //回送时钟频率 8位数据
;;;424                       8,                         
;;;425                       CLK_FREQ_ASC);             
;;;426            if(DAY_ERR_ASC[7]=='.')               //日计时误差>=1000000S 回送7位数据
;;;427             Send_Data(ERR_OCMD_DAY_ERR,          //回送脉冲周期命令
;;;428                       7,                         
;;;429                       DAY_ERR_ASC);              //日计时误差
;;;430            else        	                        
;;;431             Send_Data(ERR_OCMD_DAY_ERR,          //日计时误差 8位数据
;;;432                       8,
;;;433                       DAY_ERR_ASC);
;;;434           }
;;;435          else
;;;436           {
;;;437           	if(NO_STD_CLK)                       //没有测到晶振脉冲
;;;438           	 return;	
;;;439            if(CLK_Cnt_NSub>CLK_Cnt_OSub)
;;;440             Cnt=CLK_Cnt_NSub-CLK_Cnt_OSub;      //跳变脉冲数
;;;441            else
;;;442             Cnt=CLK_Cnt_OSub-CLK_Cnt_NSub;      //跳变脉冲数
;;;443            CLK_Cnt_OSub=CLK_Cnt_NSub;
;;;444            if(CLK_STB_CHK)                      //判断是否临时不检查稳定
;;;445             {
;;;446              if(CLK_RELOAD_TIME!=CLK_RELOAD_Cnt)//记录两个脉冲开始检测 
;;;447               CLK_STB_CHK=0;                    //启动稳定检测       
;;;448              return;
;;;449             }             
;;;450            if(Cnt>CLK_STB_RNG)                  //判断跳变是否超出范围
;;;451             {
;;;452              FIRST_CLK_PLS=1;                   //重新计脉冲
;;;453              return;
;;;454             }
;;;455            CLK_NEW_ACT_FREQ=STD_CLK_VAL_ONE;    //标准时钟脉冲数
;;;456            if(CLK_Cnt_NSub<100)                 //计数值太小 认为没有标准时钟脉冲或测量频率太高
;;;457             {
;;;458              if(CLK_FREQ_SET<1.1)
;;;459               {
;;;460                CLK_FREQ_SET=100;                //设定频率100Hz
;;;461                Cal_Clk_Reload(1);
;;;462               }
;;;463              else if(CLK_FREQ_SET>1000)         //设定频率大于1K时,收到的脉冲太少 认为没有标准脉冲
;;;464               {
;;;465                NO_STD_CLK=1;                    //没有标准时钟脉冲
;;;466               }  
;;;467              else
;;;468               {
;;;469                CLK_FREQ_SET*=100;               //设定频率提高100倍
;;;470                Cal_Clk_Reload(1);               //重新计算
;;;471               } 
;;;472              return; 
;;;473             }                             
;;;474            CLK_NEW_ACT_FREQ/=CLK_Cnt_NSub;      //精度较低的实际频率
;;;475           }
;;;476          if(CLK_OLD_ACT_FREQ==0)
000602  f8df82d0          LDR      r8,|L1.2260|
000606  4ea7              LDR      r6,|L1.2212|
000608  4f9f              LDR      r7,|L1.2184|
00060a  2900              CMP      r1,#0                 ;366
00060c  d17e              BNE      |L1.1804|
00060e  48b2              LDR      r0,|L1.2264|
000610  f8df92c8          LDR      r9,|L1.2268|
000614  6801              LDR      r1,[r0,#0]            ;368  ; NEW_CLK_Cnt
000616  f8d90000          LDR      r0,[r9,#0]            ;368  ; OLD_CLK_Cnt
00061a  1a08              SUBS     r0,r1,r0              ;368
00061c  f8c91000          STR      r1,[r9,#0]            ;369  ; OLD_CLK_Cnt
000620  f8ac3000          STRH     r3,[r12,#0]           ;370
000624  280a              CMP      r0,#0xa               ;371
000626  d213              BCS      |L1.1616|
000628  6014              STR      r4,[r2,#0]            ;373  ; NO_STD_CLK
00062a  a1ad              ADR      r1,|L1.2272|
00062c  48ae              LDR      r0,|L1.2280|
00062e  f7fffffe          BL       strcpy
000632  4aad              LDR      r2,|L1.2280|
000634  2107              MOVS     r1,#7                 ;376
000636  f44f7082          MOV      r0,#0x104             ;376
00063a  f7fffffe          BL       Send_Data
00063e  b004              ADD      sp,sp,#0x10           ;379
000640  e8bd5ff0          POP      {r4-r12,lr}           ;379
000644  4aa8              LDR      r2,|L1.2280|
000646  2107              MOVS     r1,#7                 ;379
000648  f2401005          MOV      r0,#0x105             ;379
00064c  f7ffbffe          B.W      Send_Data
                  |L1.1616|
000650  6015              STR      r5,[r2,#0]            ;386  ; NO_STD_CLK
000652  49a6              LDR      r1,|L1.2284|
000654  e9d19a00          LDRD     r9,r10,[r1,#0]        ;387
000658  f7fffffe          BL       __aeabi_ui2d
00065c  e9cd0102          STRD     r0,r1,[sp,#8]         ;388
000660  460b              MOV      r3,r1                 ;388
000662  4602              MOV      r2,r0                 ;388
000664  4651              MOV      r1,r10                ;388
000666  4648              MOV      r0,r9                 ;388
000668  f7fffffe          BL       __aeabi_ddiv
00066c  4681              MOV      r9,r0                 ;388
00066e  468a              MOV      r10,r1                ;388
000670  e9c60100          STRD     r0,r1,[r6,#0]         ;388
000674  210c              MOVS     r1,#0xc               ;389
000676  489e              LDR      r0,|L1.2288|
000678  f7fffffe          BL       __aeabi_memclr
00067c  4653              MOV      r3,r10                ;390
00067e  464a              MOV      r2,r9                 ;390
000680  a19c              ADR      r1,|L1.2292|
000682  489b              LDR      r0,|L1.2288|
000684  f7fffffe          BL       __2sprintf
000688  e9d6ab00          LDRD     r10,r11,[r6,#0]       ;393
00068c  f8df926c          LDR      r9,|L1.2300|
000690  6838              LDR      r0,[r7,#0]            ;394  ; CLK_FREQ_SET
000692  f7fffffe          BL       __aeabi_f2d
000696  e9cd0102          STRD     r0,r1,[sp,#8]         ;394
00069a  460b              MOV      r3,r1                 ;394
00069c  4602              MOV      r2,r0                 ;394
00069e  4659              MOV      r1,r11                ;394
0006a0  4650              MOV      r0,r10                ;394
0006a2  f7fffffe          BL       __aeabi_ddiv
0006a6  a274              ADR      r2,|L1.2168|
0006a8  ca0c              LDM      r2,{r2,r3}            ;395
0006aa  f7fffffe          BL       __aeabi_dsub
0006ae  a294              ADR      r2,|L1.2304|
0006b0  ca0c              LDM      r2,{r2,r3}            ;396
0006b2  f7fffffe          BL       __aeabi_dmul
0006b6  e9c90100          STRD     r0,r1,[r9,#0]         ;396
0006ba  460b              MOV      r3,r1                 ;397
0006bc  4602              MOV      r2,r0                 ;397
0006be  a192              ADR      r1,|L1.2312|
0006c0  4893              LDR      r0,|L1.2320|
0006c2  f7fffffe          BL       __2sprintf
0006c6  4893              LDR      r0,|L1.2324|
0006c8  6004              STR      r4,[r0,#0]            ;400  ; NEW_CLK_DATA
0006ca  e000              B        |L1.1742|
                  |L1.1740|
0006cc  e059              B        |L1.1922|
                  |L1.1742|
0006ce  4892              LDR      r0,|L1.2328|
0006d0  4992              LDR      r1,|L1.2332|
0006d2  7800              LDRB     r0,[r0,#0]            ;401  ; Disp_Choose
0006d4  2801              CMP      r0,#1                 ;401
0006d6  d107              BNE      |L1.1768|
0006d8  200f              MOVS     r0,#0xf               ;403
0006da  7008              STRB     r0,[r1,#0]            ;403
0006dc  4a84              LDR      r2,|L1.2288|
0006de  2101              MOVS     r1,#1                 ;404
0006e0  2008              MOVS     r0,#8                 ;404
0006e2  f7fffffe          BL       Copy_Str_To_DSBUF
0006e6  e00a              B        |L1.1790|
                  |L1.1768|
0006e8  2802              CMP      r0,#2                 ;409
0006ea  d108              BNE      |L1.1790|
0006ec  2017              MOVS     r0,#0x17              ;411
0006ee  7008              STRB     r0,[r1,#0]            ;411
0006f0  2015              MOVS     r0,#0x15              ;412
0006f2  7048              STRB     r0,[r1,#1]            ;412
0006f4  4a86              LDR      r2,|L1.2320|
0006f6  2102              MOVS     r1,#2                 ;413
0006f8  2007              MOVS     r0,#7                 ;413
0006fa  f7fffffe          BL       Copy_Str_To_DSBUF
                  |L1.1790|
0006fe  487c              LDR      r0,|L1.2288|
000700  79c0              LDRB     r0,[r0,#7]            ;418  ; CLK_FREQ_ASC
000702  282e              CMP      r0,#0x2e              ;418
000704  d108              BNE      |L1.1816|
000706  4a7a              LDR      r2,|L1.2288|
000708  2107              MOVS     r1,#7                 ;419
00070a  e000              B        |L1.1806|
                  |L1.1804|
00070c  e01c              B        |L1.1864|
                  |L1.1806|
00070e  f44f7082          MOV      r0,#0x104             ;419
000712  f7fffffe          BL       Send_Data
000716  e005              B        |L1.1828|
                  |L1.1816|
000718  4a75              LDR      r2,|L1.2288|
00071a  2108              MOVS     r1,#8                 ;423
00071c  f44f7082          MOV      r0,#0x104             ;423
000720  f7fffffe          BL       Send_Data
                  |L1.1828|
000724  487a              LDR      r0,|L1.2320|
000726  79c0              LDRB     r0,[r0,#7]            ;426  ; DAY_ERR_ASC
000728  282e              CMP      r0,#0x2e              ;426
00072a  d106              BNE      |L1.1850|
00072c  4a78              LDR      r2,|L1.2320|
00072e  2107              MOVS     r1,#7                 ;427
000730  f2401005          MOV      r0,#0x105             ;427
000734  f7fffffe          BL       Send_Data
000738  e057              B        |L1.2026|
                  |L1.1850|
00073a  4a75              LDR      r2,|L1.2320|
00073c  2108              MOVS     r1,#8                 ;431
00073e  f2401005          MOV      r0,#0x105             ;431
000742  f7fffffe          BL       Send_Data
000746  e050              B        |L1.2026|
                  |L1.1864|
000748  6810              LDR      r0,[r2,#0]            ;437  ; NO_STD_CLK
00074a  2800              CMP      r0,#0                 ;437
00074c  d119              BNE      |L1.1922|
00074e  4874              LDR      r0,|L1.2336|
000750  f8df91d0          LDR      r9,|L1.2340|
000754  6800              LDR      r0,[r0,#0]            ;439  ; CLK_Cnt_NSub
000756  f8d9c000          LDR      r12,[r9,#0]           ;439  ; CLK_Cnt_OSub
00075a  4560              CMP      r0,r12                ;439
00075c  d902              BLS      |L1.1892|
00075e  eba00c0c          SUB      r12,r0,r12            ;440
000762  e001              B        |L1.1896|
                  |L1.1892|
000764  ebac0c00          SUB      r12,r12,r0            ;442
                  |L1.1896|
000768  f8c90000          STR      r0,[r9,#0]            ;443  ; CLK_Cnt_OSub
00076c  f8df91b8          LDR      r9,|L1.2344|
000770  f8d9a000          LDR      r10,[r9,#0]           ;444  ; CLK_STB_CHK
000774  f1ba0f00          CMP      r10,#0                ;444
000778  d005              BEQ      |L1.1926|
00077a  428b              CMP      r3,r1                 ;446
00077c  d001              BEQ      |L1.1922|
00077e  f8c95000          STR      r5,[r9,#0]            ;447  ; CLK_STB_CHK
                  |L1.1922|
;;;477           { 
;;;478            CLK_OLD_ACT_FREQ=CLK_NEW_ACT_FREQ;   //更新频率
;;;479            return;
;;;480           } 
;;;481          if(CLK_NEW_ACT_FREQ>CLK_OLD_ACT_FREQ)
;;;482           f=CLK_NEW_ACT_FREQ/CLK_OLD_ACT_FREQ;  //新旧频率对比
;;;483          else
;;;484           f=CLK_OLD_ACT_FREQ/CLK_NEW_ACT_FREQ;
;;;485          CLK_OLD_ACT_FREQ=CLK_NEW_ACT_FREQ; 
;;;486          if(f>1.001)                            //频率变化在0.1%内认为稳定
;;;487           return;                               //频率
;;;488          if(CLK_NEW_ACT_FREQ>CLK_FREQ_SET)      //以下为自动调整重装值和重装次数
;;;489           f=CLK_NEW_ACT_FREQ/CLK_FREQ_SET;      //实测频率与设定频率的比值
;;;490          else                                  
;;;491           f=CLK_FREQ_SET/CLK_NEW_ACT_FREQ;      //实测频率与设定频率的比值
;;;492          if(f>1.0005)                           //设定频率与实测频率超过0.05%
;;;493           {                                     //设定频率错误 调整测量时间
;;;494            if(!CLK_SET_ERR)                     //连续出现两次错误 调整
;;;495             {                                   
;;;496              CLK_SET_ERR=1;                     //时钟频率设置错误标志                 
;;;497              return;                            
;;;498             }  
;;;499            Act_Freq_to_Set();                   //估算设定频率            
;;;500            Cal_Clk_Reload(1);                   //自动调整测量重装值和重装次数
;;;501           }                                     
;;;502          else                                   
;;;503           CLK_SET_ERR=0;                        //清除频率设置错误标志
;;;504         }
;;;505    }
000782  e8bd9fff          POP      {r0-r12,pc}
                  |L1.1926|
000786  4969              LDR      r1,|L1.2348|
000788  8809              LDRH     r1,[r1,#0]            ;450  ; CLK_STB_RNG
00078a  458c              CMP      r12,r1                ;450
00078c  d902              BLS      |L1.1940|
00078e  4868              LDR      r0,|L1.2352|
000790  6004              STR      r4,[r0,#0]            ;452  ; FIRST_CLK_PLS
000792  e7f6              B        |L1.1922|
                  |L1.1940|
000794  4967              LDR      r1,|L1.2356|
000796  e9d19a00          LDRD     r9,r10,[r1,#0]        ;455
00079a  e9c69a00          STRD     r9,r10,[r6,#0]        ;455
00079e  2864              CMP      r0,#0x64              ;456
0007a0  d217              BCS      |L1.2002|
0007a2  4b65              LDR      r3,|L1.2360|
0007a4  6838              LDR      r0,[r7,#0]            ;458  ; CLK_FREQ_SET
0007a6  4965              LDR      r1,|L1.2364|
0007a8  4298              CMP      r0,r3                 ;458
0007aa  da05              BGE      |L1.1976|
0007ac  6039              STR      r1,[r7,#0]            ;460  ; CLK_FREQ_SET
0007ae  b004              ADD      sp,sp,#0x10           ;461
0007b0  e8bd5ff0          POP      {r4-r12,lr}           ;461
0007b4  2001              MOVS     r0,#1                 ;461
0007b6  e7fe              B        Cal_Clk_Reload
                  |L1.1976|
0007b8  4b61              LDR      r3,|L1.2368|
0007ba  4298              CMP      r0,r3                 ;463
0007bc  dd01              BLE      |L1.1986|
0007be  6014              STR      r4,[r2,#0]            ;465  ; NO_STD_CLK
0007c0  e7df              B        |L1.1922|
                  |L1.1986|
0007c2  f7fffffe          BL       __aeabi_fmul
0007c6  6038              STR      r0,[r7,#0]            ;469  ; CLK_FREQ_SET
0007c8  b004              ADD      sp,sp,#0x10           ;470
0007ca  e8bd5ff0          POP      {r4-r12,lr}           ;470
0007ce  2001              MOVS     r0,#1                 ;470
0007d0  e7fe              B        Cal_Clk_Reload
                  |L1.2002|
0007d2  f7fffffe          BL       __aeabi_ui2d
0007d6  e9cd0102          STRD     r0,r1,[sp,#8]         ;474
0007da  460b              MOV      r3,r1                 ;474
0007dc  4602              MOV      r2,r0                 ;474
0007de  4651              MOV      r1,r10                ;474
0007e0  4648              MOV      r0,r9                 ;474
0007e2  f7fffffe          BL       __aeabi_ddiv
0007e6  e9c60100          STRD     r0,r1,[r6,#0]         ;474
                  |L1.2026|
0007ea  a056              ADR      r0,|L1.2372|
0007ec  c80c              LDM      r0!,{r2,r3}           ;476
0007ee  e9d80100          LDRD     r0,r1,[r8,#0]         ;476
0007f2  f7fffffe          BL       __aeabi_cdcmpeq
0007f6  d103              BNE      |L1.2048|
0007f8  ce03              LDM      r6!,{r0,r1}           ;478
0007fa  e9c80100          STRD     r0,r1,[r8,#0]         ;478
0007fe  e7c0              B        |L1.1922|
                  |L1.2048|
000800  e9d82300          LDRD     r2,r3,[r8,#0]         ;481
000804  e9d60100          LDRD     r0,r1,[r6,#0]         ;481
000808  f7fffffe          BL       __aeabi_cdrcmple
00080c  d20a              BCS      |L1.2084|
00080e  e9d82300          LDRD     r2,r3,[r8,#0]         ;482
000812  e9d60100          LDRD     r0,r1,[r6,#0]         ;482
000816  f7fffffe          BL       __aeabi_ddiv
00081a  e9cd0102          STRD     r0,r1,[sp,#8]         ;482
00081e  f7fffffe          BL       __aeabi_d2f
000822  e009              B        |L1.2104|
                  |L1.2084|
000824  e9d62300          LDRD     r2,r3,[r6,#0]         ;484
000828  e9d80100          LDRD     r0,r1,[r8,#0]         ;484
00082c  f7fffffe          BL       __aeabi_ddiv
000830  e9cd0102          STRD     r0,r1,[sp,#8]         ;484
000834  f7fffffe          BL       __aeabi_d2f
                  |L1.2104|
000838  e9d69a00          LDRD     r9,r10,[r6,#0]        ;485
00083c  e9c89a00          STRD     r9,r10,[r8,#0]        ;485
000840  4942              LDR      r1,|L1.2380|
000842  4288              CMP      r0,r1                 ;486
000844  da9d              BGE      |L1.1922|
000846  6838              LDR      r0,[r7,#0]            ;488  ; CLK_FREQ_SET
000848  f7fffffe          BL       __aeabi_f2d
00084c  4653              MOV      r3,r10                ;488
00084e  464a              MOV      r2,r9                 ;488
000850  e9cd0102          STRD     r0,r1,[sp,#8]         ;488
000854  f7fffffe          BL       __aeabi_cdcmple
000858  d27b              BCS      |L1.2386|
00085a  6838              LDR      r0,[r7,#0]            ;489  ; CLK_FREQ_SET
00085c  f7fffffe          BL       __aeabi_f2d
000860  460b              MOV      r3,r1                 ;489
000862  4602              MOV      r2,r0                 ;489
000864  e9cd0102          STRD     r0,r1,[sp,#8]         ;489
000868  ce03              LDM      r6!,{r0,r1}           ;489
00086a  f7fffffe          BL       __aeabi_ddiv
00086e  e9cd0100          STRD     r0,r1,[sp,#0]         ;489
000872  f7fffffe          BL       __aeabi_d2f
000876  e078              B        |L1.2410|
                  |L1.2168|
000878  00000000          DCFD     0x3ff0000000000000 ; 1
00087c  3ff00000
                  |L1.2176|
000880  00000000          DCFD     0x40c3880000000000 ; 10000
000884  40c38800
                  |L1.2184|
                          DCD      CLK_FREQ_SET
                  |L1.2188|
                          DCD      0x461c4000
                  |L1.2192|
                          DCD      NO_CLK_PLS
                  |L1.2196|
                          DCD      CLK_Timer
                  |L1.2200|
                          DCD      CLK_Timer_Max
                  |L1.2204|
                          DCD      0x40031000
                  |L1.2208|
                          DCD      CLK_RELOAD_VAL
                  |L1.2212|
                          DCD      CLK_NEW_ACT_FREQ
                  |L1.2216|
0008a8  00000000          DCFD     0x408f400000000000 ; 1000
0008ac  408f4000
                  |L1.2224|
0008b0  eb1c432d          DCFD     0x3f1a36e2eb1c432d ; 0.0001
0008b4  3f1a36e2
                  |L1.2232|
                          DCD      WORK_MODE
                  |L1.2236|
                          DCD      MFClk_Mode
                  |L1.2240|
                          DCD      MFClk_Type
                  |L1.2244|
                          DCD      NEW_CLK_PLS
                  |L1.2248|
                          DCD      CLK_RELOAD_Cnt
                  |L1.2252|
                          DCD      CLK_RELOAD_TIME
                  |L1.2256|
                          DCD      NO_STD_CLK
                  |L1.2260|
                          DCD      CLK_OLD_ACT_FREQ
                  |L1.2264|
                          DCD      NEW_CLK_Cnt
                  |L1.2268|
                          DCD      OLD_CLK_Cnt
                  |L1.2272|
0008e0  4e6f204a          DCB      "No JZMC",0
0008e4  5a4d4300
                  |L1.2280|
                          DCD      TEMP_STR
                  |L1.2284|
                          DCD      STD_CLK_VAL_SUM
                  |L1.2288|
                          DCD      CLK_FREQ_ASC
                  |L1.2292|
0008f4  2531322e          DCB      "%12.10f",0
0008f8  31306600
                  |L1.2300|
                          DCD      CLK_DAY_ERR
                  |L1.2304|
000900  00000000          DCFD     0x40f5180000000000 ; 86400
000904  40f51800
                  |L1.2312|
000908  25382e36          DCB      "%8.6f",0
00090c  6600    
00090e  00                DCB      0
00090f  00                DCB      0
                  |L1.2320|
                          DCD      DAY_ERR_ASC
                  |L1.2324|
                          DCD      NEW_CLK_DATA
                  |L1.2328|
                          DCD      Disp_Choose
                  |L1.2332|
                          DCD      Disp_Buf
                  |L1.2336|
                          DCD      CLK_Cnt_NSub
                  |L1.2340|
                          DCD      CLK_Cnt_OSub
                  |L1.2344|
                          DCD      CLK_STB_CHK
                  |L1.2348|
                          DCD      CLK_STB_RNG
                  |L1.2352|
                          DCD      FIRST_CLK_PLS
                  |L1.2356|
                          DCD      STD_CLK_VAL_ONE
                  |L1.2360|
                          DCD      0x3f8ccccd
                  |L1.2364|
                          DCD      0x42c80000
                  |L1.2368|
                          DCD      0x447a0000
                  |L1.2372|
000944  00000000          DCFD     0x0000000000000000 ; 0
000948  00000000
                  |L1.2380|
                          DCD      0x3f8020c5
000950  e7ff              B        |L1.2386|
                  |L1.2386|
000952  6838              LDR      r0,[r7,#0]            ;491  ; CLK_FREQ_SET
000954  f7fffffe          BL       __aeabi_f2d
000958  e9cd0102          STRD     r0,r1,[sp,#8]         ;491
00095c  ce0c              LDM      r6!,{r2,r3}           ;491
00095e  f7fffffe          BL       __aeabi_ddiv
000962  e9cd0100          STRD     r0,r1,[sp,#0]         ;491
000966  f7fffffe          BL       __aeabi_d2f
                  |L1.2410|
00096a  4a77              LDR      r2,|L1.2888|
00096c  4977              LDR      r1,|L1.2892|
00096e  4290              CMP      r0,r2                 ;492
000970  dd0b              BLE      |L1.2442|
000972  6808              LDR      r0,[r1,#0]            ;494  ; CLK_SET_ERR
000974  b908              CBNZ     r0,|L1.2426|
000976  600c              STR      r4,[r1,#0]            ;496  ; CLK_SET_ERR
000978  e703              B        |L1.1922|
                  |L1.2426|
00097a  f7fffffe          BL       Act_Freq_to_Set
00097e  b004              ADD      sp,sp,#0x10           ;500
000980  e8bd5ff0          POP      {r4-r12,lr}           ;500
000984  2001              MOVS     r0,#1                 ;500
000986  f7ffbffe          B.W      Cal_Clk_Reload
                  |L1.2442|
00098a  600d              STR      r5,[r1,#0]            ;503  ; CLK_SET_ERR
00098c  e6f9              B        |L1.1922|
;;;506    /********************************************************
                          ENDP

                  MEA_XUL_TIME PROC
;;;522    ********************************************************/
;;;523    void MEA_XUL_TIME(void)        
00098e  e92d41fc          PUSH     {r2-r8,lr}
;;;524    {
;;;525        if(WORK_MODE==MEA_ENG_DUTY_M)           //判断是否在测量脉冲周期
000992  486f              LDR      r0,|L1.2896|
000994  7800              LDRB     r0,[r0,#0]  ; WORK_MODE
000996  280b              CMP      r0,#0xb
000998  d026              BEQ      |L1.2536|
;;;526         return;                                //退出
;;;527        if(MFClk_Mode==UNION_PLS)               //判断脉冲是否为联合脉冲
00099a  486e              LDR      r0,|L1.2900|
00099c  7800              LDRB     r0,[r0,#0]  ; MFClk_Mode
00099e  2831              CMP      r0,#0x31
0009a0  d103              BNE      |L1.2474|
;;;528         if(MFClk_Type!=XULCLK_PLS)             //判断联合脉冲状态下 是否正在需量周期
0009a2  486d              LDR      r0,|L1.2904|
0009a4  7800              LDRB     r0,[r0,#0]  ; MFClk_Type
0009a6  2832              CMP      r0,#0x32
0009a8  d11e              BNE      |L1.2536|
                  |L1.2474|
;;;529          return;                               //不在测量时钟脉冲 退出		
;;;530        if(NEW_XUL_PLS)                         //收到新时钟脉冲
0009aa  486c              LDR      r0,|L1.2908|
0009ac  6801              LDR      r1,[r0,#0]  ; NEW_XUL_PLS
0009ae  2900              CMP      r1,#0
0009b0  d01a              BEQ      |L1.2536|
;;;531         {
;;;532          NEW_XUL_PLS=0;                        //清除收到新时钟脉冲标志
0009b2  2700              MOVS     r7,#0
0009b4  6007              STR      r7,[r0,#0]  ; NEW_XUL_PLS
;;;533          if(NO_STD_CLK)                        //判断标准时钟脉冲是否存在
0009b6  4e6a              LDR      r6,|L1.2912|
0009b8  6830              LDR      r0,[r6,#0]  ; NO_STD_CLK
0009ba  2800              CMP      r0,#0
0009bc  d114              BNE      |L1.2536|
;;;534           return;                              //退出
;;;535          XUL_RELOAD_Cnt--;
0009be  4869              LDR      r0,|L1.2916|
0009c0  7801              LDRB     r1,[r0,#0]  ; XUL_RELOAD_Cnt
0009c2  1e49              SUBS     r1,r1,#1
0009c4  b2c9              UXTB     r1,r1
0009c6  7001              STRB     r1,[r0,#0]
;;;536          if(XUL_RELOAD_Cnt==0)                 //判断设定分频计数是否到
;;;537           {  
;;;538            XUL_RELOAD_Cnt=XUL_RELOAD_TIME;     //重装计数值
0009c8  4a67              LDR      r2,|L1.2920|
;;;539            if(XUL_Cnt_Sum<10)                  //标准时钟脉冲计数值是否太小
;;;540             {
;;;541              NO_STD_CLK=1;                     //没有标准脉冲
0009ca  2501              MOVS     r5,#1
0009cc  7812              LDRB     r2,[r2,#0]            ;538
0009ce  4c67              LDR      r4,|L1.2924|
0009d0  2900              CMP      r1,#0                 ;536
0009d2  d14e              BNE      |L1.2674|
0009d4  7002              STRB     r2,[r0,#0]            ;538
0009d6  f2af5054          ADR      r0,|L1.1156|
0009da  c80c              LDM      r0!,{r2,r3}           ;539
0009dc  e9d40100          LDRD     r0,r1,[r4,#0]         ;539
0009e0  f7fffffe          BL       __aeabi_cdcmple
0009e4  d201              BCS      |L1.2538|
0009e6  6035              STR      r5,[r6,#0]  ; NO_STD_CLK
                  |L1.2536|
;;;542              return;                           //退出
;;;543             } 
;;;544            XUL_Cnt_Sum/=1000000;               //除以标准时钟频率即为需量周期 单位:s
;;;545            XUL_TIME = XUL_Cnt_Sum;             //保存需量周期
;;;546            XUL_Cnt_Sum=0;                      //需量计数值归零
;;;547            memset(XUL_TIME_ASC,0,8);           //清除需量周期ASC
;;;548            sprintf(XUL_TIME_ASC,               //输出时钟频率ASC缓冲区  返回输出数据长度
;;;549                    "%8.6f",                    //数据最长8位 最大6位小数
;;;550                    XUL_TIME);                  //实测需量周期
;;;551            NEW_XUL_DATA=1;                     //有新数据标志
;;;552            if(Disp_Choose==DISP_XUL_TIME)      //判断是否在显示需量周期模式
;;;553             {
;;;554              Disp_Buf[0]=DISP_L;               //显示'L'
;;;555              Disp_Buf[1]=DISP_BLANK;           //显示空
;;;556              Copy_Str_To_DSBUF(DISP_XUL_LEN,   //需量周期数据长度
;;;557                                DISP_XUL_OFFSET,//需量周期显示偏移量
;;;558                                XUL_TIME_ASC);  //需量周期ASC地址   
;;;559             }
;;;560            if(XUL_TIME_ASC[7]=='.')                //需量周期>=1000000S 回送7位数据
;;;561             Send_Data(ERR_OCMD_XULZQ,          //回送脉冲周期命令
;;;562                       7,                         
;;;563                       XUL_TIME_ASC);               //回送时钟频率
;;;564            else        	                        
;;;565             Send_Data(ERR_OCMD_XULZQ,          //回送时钟频率 8位数据
;;;566                       8,                         
;;;567                       XUL_TIME_ASC);             
;;;568           }
;;;569          else
;;;570           {
;;;571            u32 Cnt;
;;;572            if(XUL_Cnt_NSub>XUL_Cnt_OSub)
;;;573             Cnt=XUL_Cnt_NSub-XUL_Cnt_OSub;      //跳变脉冲数
;;;574            else
;;;575             Cnt=XUL_Cnt_OSub-XUL_Cnt_NSub;      //跳变脉冲数
;;;576            XUL_Cnt_OSub=XUL_Cnt_NSub;
;;;577            if(XUL_STB_CHK)                      //判断是否临时不检查稳定
;;;578             {
;;;579              if(XUL_RELOAD_TIME!=XUL_RELOAD_Cnt)//记录两个脉冲开始检测 
;;;580               XUL_STB_CHK=0;                    //启动稳定检测       
;;;581              return;
;;;582             }             
;;;583            if(Cnt>1000)                         //判断跳变是否超过1ms
;;;584             {
;;;585              FIRST_XUL_PLS=1;                   //重新计脉冲
;;;586              return;
;;;587             }
;;;588           }  
;;;589         }
;;;590    }
0009e8  e5e3              B        |L1.1458|
                  |L1.2538|
0009ea  f2af50e0          ADR      r0,|L1.1036|
0009ee  c80c              LDM      r0!,{r2,r3}           ;544
0009f0  e9d40100          LDRD     r0,r1,[r4,#0]         ;544
0009f4  f7fffffe          BL       __aeabi_ddiv
0009f8  f7fffffe          BL       __aeabi_d2f
0009fc  495c              LDR      r1,|L1.2928|
0009fe  4606              MOV      r6,r0                 ;545
000a00  6008              STR      r0,[r1,#0]            ;545  ; XUL_TIME
000a02  f2af00c0          ADR      r0,|L1.2372|
000a06  c803              LDM      r0,{r0,r1}            ;546
000a08  c403              STM      r4!,{r0,r1}           ;546
000a0a  2108              MOVS     r1,#8                 ;547
000a0c  4859              LDR      r0,|L1.2932|
000a0e  f7fffffe          BL       __aeabi_memclr
000a12  4630              MOV      r0,r6                 ;548
000a14  f7fffffe          BL       __aeabi_f2d
000a18  460b              MOV      r3,r1                 ;548
000a1a  4602              MOV      r2,r0                 ;548
000a1c  e9cd0100          STRD     r0,r1,[sp,#0]         ;548
000a20  f2af111c          ADR      r1,|L1.2312|
000a24  4853              LDR      r0,|L1.2932|
000a26  f7fffffe          BL       __2sprintf
000a2a  4853              LDR      r0,|L1.2936|
000a2c  6005              STR      r5,[r0,#0]            ;551  ; NEW_XUL_DATA
000a2e  4853              LDR      r0,|L1.2940|
000a30  7800              LDRB     r0,[r0,#0]            ;552  ; Disp_Choose
000a32  2803              CMP      r0,#3                 ;552
000a34  d109              BNE      |L1.2634|
000a36  4852              LDR      r0,|L1.2944|
000a38  2112              MOVS     r1,#0x12              ;554
000a3a  7001              STRB     r1,[r0,#0]            ;554
000a3c  2115              MOVS     r1,#0x15              ;555
000a3e  7041              STRB     r1,[r0,#1]            ;555
000a40  4a4c              LDR      r2,|L1.2932|
000a42  2102              MOVS     r1,#2                 ;556
000a44  2007              MOVS     r0,#7                 ;556
000a46  f7fffffe          BL       Copy_Str_To_DSBUF
                  |L1.2634|
000a4a  484a              LDR      r0,|L1.2932|
000a4c  79c1              LDRB     r1,[r0,#7]            ;560  ; XUL_TIME_ASC
000a4e  f44f7083          MOV      r0,#0x106             ;561
000a52  292e              CMP      r1,#0x2e              ;560
000a54  d106              BNE      |L1.2660|
000a56  b002              ADD      sp,sp,#8              ;561
000a58  e8bd41f0          POP      {r4-r8,lr}            ;561
000a5c  4a45              LDR      r2,|L1.2932|
000a5e  2107              MOVS     r1,#7                 ;561
000a60  f7ffbffe          B.W      Send_Data
                  |L1.2660|
000a64  b002              ADD      sp,sp,#8              ;565
000a66  e8bd41f0          POP      {r4-r8,lr}            ;565
000a6a  4a42              LDR      r2,|L1.2932|
000a6c  2108              MOVS     r1,#8                 ;565
000a6e  f7ffbffe          B.W      Send_Data
                  |L1.2674|
000a72  4844              LDR      r0,|L1.2948|
000a74  4c44              LDR      r4,|L1.2952|
000a76  6800              LDR      r0,[r0,#0]            ;572  ; XUL_Cnt_NSub
000a78  6823              LDR      r3,[r4,#0]            ;572  ; XUL_Cnt_OSub
000a7a  4298              CMP      r0,r3                 ;572
000a7c  d901              BLS      |L1.2690|
000a7e  1ac3              SUBS     r3,r0,r3              ;573
000a80  e000              B        |L1.2692|
                  |L1.2690|
000a82  1a1b              SUBS     r3,r3,r0              ;575
                  |L1.2692|
000a84  6020              STR      r0,[r4,#0]            ;576  ; XUL_Cnt_OSub
000a86  4841              LDR      r0,|L1.2956|
000a88  6804              LDR      r4,[r0,#0]            ;577  ; XUL_STB_CHK
000a8a  b11c              CBZ      r4,|L1.2708|
000a8c  428a              CMP      r2,r1                 ;579
000a8e  d0ab              BEQ      |L1.2536|
000a90  6007              STR      r7,[r0,#0]            ;580  ; XUL_STB_CHK
000a92  e58e              B        |L1.1458|
                  |L1.2708|
000a94  f5b37f7a          CMP      r3,#0x3e8             ;583
000a98  d9a6              BLS      |L1.2536|
000a9a  483d              LDR      r0,|L1.2960|
000a9c  6005              STR      r5,[r0,#0]            ;585  ; FIRST_XUL_PLS
000a9e  e588              B        |L1.1458|
;;;591    /********************************************************
                          ENDP

                  Proc_MFuction_PLS PROC
;;;593    ********************************************************/
;;;594    void Proc_MFuction_PLS(void)
000aa0  b510              PUSH     {r4,lr}
;;;595    {
;;;596        if(NEW_HZ_PLS)                           //判断是否有合闸脉冲信号
000aa2  483c              LDR      r0,|L1.2964|
000aa4  2400              MOVS     r4,#0
000aa6  6801              LDR      r1,[r0,#0]  ; NEW_HZ_PLS
000aa8  b151              CBZ      r1,|L1.2752|
;;;597         {
;;;598          NEW_HZ_PLS=0;                          //清除合闸标志
000aaa  6004              STR      r4,[r0,#0]  ; NEW_HZ_PLS
;;;599          strcpy(TEMP_STR,
000aac  a13a              ADR      r1,|L1.2968|
000aae  483c              LDR      r0,|L1.2976|
000ab0  f7fffffe          BL       strcpy
;;;600                 "HZMC");
;;;601          Send_Data(ERR_OCMD_HZMC,               //回送收到合闸脉冲信号
000ab4  4a3a              LDR      r2,|L1.2976|
000ab6  2104              MOVS     r1,#4
000ab8  f44f7084          MOV      r0,#0x108
000abc  f7fffffe          BL       Send_Data
                  |L1.2752|
;;;602                    4,                           
;;;603                    TEMP_STR);                   //
;;;604         }
;;;605        if(NEW_TQ_PLS)                           //投切脉冲
000ac0  4838              LDR      r0,|L1.2980|
000ac2  6801              LDR      r1,[r0,#0]  ; NEW_TQ_PLS
000ac4  2900              CMP      r1,#0
000ac6  d00c              BEQ      |L1.2786|
;;;606         {
;;;607          NEW_TQ_PLS=0;                          //清除投切脉冲标志
000ac8  6004              STR      r4,[r0,#0]  ; NEW_TQ_PLS
;;;608          strcpy(TEMP_STR,
000aca  a137              ADR      r1,|L1.2984|
000acc  4834              LDR      r0,|L1.2976|
000ace  f7fffffe          BL       strcpy
;;;609                 "TQMC");
;;;610          Send_Data(ERR_OCMD_TQMC,               //回送收到投切脉冲信号
000ad2  e8bd4010          POP      {r4,lr}
000ad6  4a32              LDR      r2,|L1.2976|
000ad8  2104              MOVS     r1,#4
000ada  f2401007          MOV      r0,#0x107
000ade  f7ffbffe          B.W      Send_Data
                  |L1.2786|
;;;611                    4,                           
;;;612                    TEMP_STR);                   //
;;;613         }	 		
;;;614    }
000ae2  bd10              POP      {r4,pc}
;;;615    /*****************************************************************************
                          ENDP

                  Proc_Xul_Pls PROC
;;;617    *****************************************************************************/
;;;618    void Proc_Xul_Pls(u16 m)
000ae4  e92d41fc          PUSH     {r2-r8,lr}
;;;619    {
;;;620        u32 Cnt;
;;;621        Cnt=STD_CLK_Cnt;                    //读标准时钟脉冲计数高位
000ae8  4931              LDR      r1,|L1.2992|
000aea  6809              LDR      r1,[r1,#0]  ; STD_CLK_Cnt
;;;622        Cnt=(Cnt<<15)+(0x8000-m);           //当前标准时钟脉冲计数值
000aec  f5c04000          RSB      r0,r0,#0x8000
000af0  eb0031c1          ADD      r1,r0,r1,LSL #15
;;;623        XUL_Timer=0;                        //清除时钟脉冲超时定时器
000af4  4a2f              LDR      r2,|L1.2996|
000af6  2000              MOVS     r0,#0
000af8  7010              STRB     r0,[r2,#0]
;;;624        NO_XUL_PLS=0;                       //收到时钟脉冲
000afa  4a2f              LDR      r2,|L1.3000|
000afc  6010              STR      r0,[r2,#0]  ; NO_XUL_PLS
;;;625        if(FIRST_XUL_PLS)                   //第一个脉冲
000afe  4a24              LDR      r2,|L1.2960|
;;;626         {                                  
;;;627          FIRST_XUL_PLS=0;                  //清除第一个脉冲标志
;;;628          NEW_XUL_PLS=0;                    //清除新脉冲
000b00  4e16              LDR      r6,|L1.2908|
;;;629          NEW_XUL_Cnt=Cnt;                  //更新当前计数
000b02  4b2e              LDR      r3,|L1.3004|
;;;630          XUL_Cnt_Sum=0;                    //清除累加值
000b04  4c19              LDR      r4,|L1.2924|
000b06  6817              LDR      r7,[r2,#0]            ;625  ; FIRST_XUL_PLS
;;;631          XUL_STB_CHK=1;                    //暂时不检查是否稳定
000b08  2501              MOVS     r5,#1
000b0a  b16f              CBZ      r7,|L1.2856|
000b0c  6010              STR      r0,[r2,#0]            ;627  ; FIRST_XUL_PLS
000b0e  6030              STR      r0,[r6,#0]            ;628  ; NEW_XUL_PLS
000b10  6019              STR      r1,[r3,#0]            ;629  ; NEW_XUL_Cnt
000b12  f2af10d0          ADR      r0,|L1.2372|
000b16  c803              LDM      r0,{r0,r1}            ;630
000b18  c403              STM      r4!,{r0,r1}           ;630
000b1a  481c              LDR      r0,|L1.2956|
000b1c  6005              STR      r5,[r0,#0]  ; XUL_STB_CHK
;;;632          XUL_RELOAD_Cnt=XUL_RELOAD_TIME;   //重置次数
000b1e  4812              LDR      r0,|L1.2920|
000b20  4910              LDR      r1,|L1.2916|
000b22  7800              LDRB     r0,[r0,#0]  ; XUL_RELOAD_TIME
000b24  7008              STRB     r0,[r1,#0]
;;;633          return;                           
;;;634         }                                  
;;;635        XUL_Cnt_NSub=Cnt-NEW_XUL_Cnt;       //一个脉冲内的标准时钟计数
;;;636        NEW_XUL_Cnt=Cnt;                    //更新当前计数
;;;637        XUL_Cnt_Sum+=XUL_Cnt_NSub;          //累加
;;;638        NEW_XUL_PLS=1;                      //收到新脉冲标志 
;;;639    }
000b26  e544              B        |L1.1458|
                  |L1.2856|
000b28  6818              LDR      r0,[r3,#0]            ;635  ; NEW_XUL_Cnt
000b2a  4a16              LDR      r2,|L1.2948|
000b2c  1a08              SUBS     r0,r1,r0              ;635
000b2e  6010              STR      r0,[r2,#0]            ;635  ; XUL_Cnt_NSub
000b30  6019              STR      r1,[r3,#0]            ;636  ; NEW_XUL_Cnt
000b32  f7fffffe          BL       __aeabi_ui2d
000b36  e9cd0100          STRD     r0,r1,[sp,#0]         ;637
000b3a  e9d42300          LDRD     r2,r3,[r4,#0]         ;637
000b3e  f7fffffe          BL       __aeabi_dadd
000b42  c403              STM      r4!,{r0,r1}           ;637
000b44  6035              STR      r5,[r6,#0]            ;638  ; NEW_XUL_PLS
000b46  e534              B        |L1.1458|
                          ENDP

                  |L1.2888|
                          DCD      0x3f801062
                  |L1.2892|
                          DCD      CLK_SET_ERR
                  |L1.2896|
                          DCD      WORK_MODE
                  |L1.2900|
                          DCD      MFClk_Mode
                  |L1.2904|
                          DCD      MFClk_Type
                  |L1.2908|
                          DCD      NEW_XUL_PLS
                  |L1.2912|
                          DCD      NO_STD_CLK
                  |L1.2916|
                          DCD      XUL_RELOAD_Cnt
                  |L1.2920|
                          DCD      XUL_RELOAD_TIME
                  |L1.2924|
                          DCD      XUL_Cnt_Sum
                  |L1.2928|
                          DCD      XUL_TIME
                  |L1.2932|
                          DCD      XUL_TIME_ASC
                  |L1.2936|
                          DCD      NEW_XUL_DATA
                  |L1.2940|
                          DCD      Disp_Choose
                  |L1.2944|
                          DCD      Disp_Buf
                  |L1.2948|
                          DCD      XUL_Cnt_NSub
                  |L1.2952|
                          DCD      XUL_Cnt_OSub
                  |L1.2956|
                          DCD      XUL_STB_CHK
                  |L1.2960|
                          DCD      FIRST_XUL_PLS
                  |L1.2964|
                          DCD      NEW_HZ_PLS
                  |L1.2968|
000b98  485a4d43          DCB      "HZMC",0
000b9c  00      
000b9d  00                DCB      0
000b9e  00                DCB      0
000b9f  00                DCB      0
                  |L1.2976|
                          DCD      TEMP_STR
                  |L1.2980|
                          DCD      NEW_TQ_PLS
                  |L1.2984|
000ba8  54514d43          DCB      "TQMC",0
000bac  00      
000bad  00                DCB      0
000bae  00                DCB      0
000baf  00                DCB      0
                  |L1.2992|
                          DCD      STD_CLK_Cnt
                  |L1.2996|
                          DCD      XUL_Timer
                  |L1.3000|
                          DCD      NO_XUL_PLS
                  |L1.3004|
                          DCD      NEW_XUL_Cnt
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_f
                          REQUIRE _printf_fp_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
